{
* Copyright (c) 2020, Reijo Pursiainen, Hannu Pursiainen
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of Reijo Pursiainen, Hannu Pursiainen nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY REIJO PURSIAINEN, HANNU PURSIAINEN AND
* CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
* BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL REIJO PURSIAINEN,
* HANNU PURSIAINEN AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
}

///////////////////////////////////////////////////////////////////////////////
//
// FileName:  NolaComp.pas
// Location:  src\components
// Abstract:  Rutiinit tekstimääreiden parsimista varten Nola-komponenteissa.
//            Määreet muistuttavat HTML-koodausta.
//
//            '<f n="Symbol" s="10" c="0">s</f>'        fontin asettaminen (n=name, s=size, c=color)
//            '<in f="10" l="20" r="30"></in>'          sisennyksen asettaminen (f=first, l=left, r=right)
//            '<tab s="10,20"></tab>'                   tabuloinnin asettaminen (s=stop)
//            '<t>'                                     tabulator
//            '<above>'                                 vertikaalinen keskitys ylös
//            '<below>'                                 vertikaalinen keskitys alas
//            '<middle>'                                vertikaalinen keskitys keskelle
//            '<left>'                                  horisontaalinen keskitys vasemmalle
//            '<right>'                                 horisontaalinen keskitys oikealle
//            '<center>'                                horisontaalinen keskitys keskelle
//            '<b>bold</b>'                             lihavointi
//            '<i>italic</i>'                           kursivointi
//            '<u>underline</u>'                        alleviivaus
//            '<s>strikeout</s>'                        yliviivaus
//            '<br>'                                    rivinvaihto
//            '<colspan c="1">'                         solun laajennus (c=colcount)
///////////////////////////////////////////////////////////////////////////////
//
// Following fields are automatically generated by the version control system:
//
// $Revision: 1.3 $
//     $Date: 2005/10/09 13:58:37 $
//
///////////////////////////////////////////////////////////////////////////////
//
// Change Log. Old log entries can be removed by deleting them.
// $Log: NolaComp.pas,v $
// Revision 1.3  2005/10/09 13:58:37  DEVELOPER2
// Reijolta 26.9.2005
//
// 
// 5     1.08.02 13:36 DEVELOPER2
// Old file header removed
// 
// 4     31.07.02 9:42 DEVELOPER2
// - New file header.
// - string parameters to consts
//
// 1    19.07.01 18:50 DEVELOPER1
// - DEVELOPER1 lisäämät kommentit tai muutokset merkitty "Kommentti: DEVELOPER1"
// - Xxx :=  Aaaa;   muutettu   Xxx :=    Aaaa; (Mahdollistaa  SIJOITUSTEN     etsimisen:  Find "Xxx := "//

unit NolaComp;

interface

uses
  Windows, Messages, SysUtils, Classes, Vcl.Graphics, Vcl.Controls,
  Vcl.Forms, Vcl.Dialogs, Vcl.ComCtrls, System.UITypes;
const                                                     //,,,,,,,,,DEVELOPER1 kommentit:
                                                                     //,, PARAMS: array [] of string;
     END_PARAM                   = 0;                     //= '"',
     COLSPAN_COLCOUNT_PARAM      = 1;                     //= ' c="',
     COLSPAN_START_PARAM         = 2;                     //= '">',
     FONT_NAME_PARAM             = 3;                     //= ' n="',
     FONT_SIZE_PARAM             = 4;                     //= '" s="',
     FONT_COLOR_PARAM            = 5;                     //= '" c="',
     FONT_START_PARAM            = 6;                     //= '">',
     INDENT_FIRST_PARAM          = 7;                     //= ' f="',
     INDENT_LEFT_PARAM           = 8;                     //= '" l="',
     INDENT_RIGHT_PARAM          = 9;                     //= '" r="',
     INDENT_START_PARAM          = 10;                    //= '">',
     TAB_STOPS_PARAM             = 11;                    //= ' s="',
     TAB_START_PARAM             = 12;                    //= '">'
                                                                     //,, TAGS: array [] of string;
     FONT_START_TAG              = 0;                     //= '<f',
     FONT_END_TAG                = 1;                     //= '</f>',
     INDENT_START_TAG            = 2;                     //= '<in',
     INDENT_END_TAG              = 3;                     //= '</in>',
     TAB_START_TAG               = 4;                     //= '<tab',
     TAB_END_TAG                 = 5;                     //= '</tab>',
     TAB_TAG                     = 6;                     //= '<t>',
     ABOVE_TAG                   = 7;                     //= '<above>',
     BELOW_TAG                   = 8;                     //= '<below>',
     MIDDLE_TAG                  = 9;                     //= '<middle>',
     LEFT_TAG                    = 10;                    //= '<left>',
     RIGHT_TAG                   = 11;                    //= '<right>',
     CENTER_TAG                  = 12;                    //= '<center>',
     FONT_BOLD_START             = 13;                    //= '<b>',
     FONT_ITALIC_START           = 14;                    //= '<i>',
     FONT_UNDERLINE_START        = 15;                    //= '<u>',
     FONT_STRIKEOUT_START        = 16;                    //= '<s>',
     FONT_BOLD_END               = 17;                    //= '</b>',
     FONT_ITALIC_END             = 18;                    //= '</i>',
     FONT_UNDERLINE_END          = 19;                    //= '</u>',
     FONT_STRIKEOUT_END          = 20;                    //= '</s>',
     LINE_BREAK                  = 21;                    //= '<br>',
     COLSPAN_START_TAG           = 22;                    //= '<colspan'

     alCenter=alNone;

     TAG_COUNT                   = 23;
     PARAM_COUNT                 = 13;

     MAX_OVERLIMIT               = 9999;

var
     tagList: TStringList = nil;
     paramList: TStringList = nil;
     longest: integer;
     longestParam: integer;
     tagsLen: array[0..TAG_COUNT - 1] of integer;
     tags: array[0..TAG_COUNT - 1] of string = (
          '<f',
          '</f>',
          '<in',
          '</in>',
          '<tab',
          '</tab>',
          '<t>',
          '<above>',
          '<below>',
          '<middle>',
          '<left>',
          '<right>',
          '<center>',
          '<b>',
          '<i>',
          '<u>',
          '<s>',
          '</b>',
          '</i>',
          '</u>',
          '</s>',
          '<br>',
          '<colspan'
     );

     paramsLen: array[0..PARAM_COUNT - 1] of integer;
     params: array[0..PARAM_COUNT - 1] of string = (
             '"',
             ' c="',
             '">',
             ' n="',
             '" s="',
             '" c="',
             '">',
             ' f="',
             '" l="',
             '" r="',
             '">',
             ' s="',
             '">'
     );

type
     TVAlign=(alBelow,alAbove,alMiddle);

     TParseResult = class(TObject)
     private
            FTabCount: integer;

            procedure SetTabCount(value: integer);
     protected
     public
           LineBreak: Boolean;
           Tabulator: Boolean;

           {Font }
           Name:    string;
           Height:  integer;
           Size:    integer;
           Pitch:   TFontPitch;
           CharSet: TFontCharset;
           Color:   TColor;
           PixelsPerInch: Integer;
           Style: TFontStyles;

           { Alignment }
           halign:   TAlign;
           valign:  TValign;

           { Paragraph }
           FirstIndent: longint;
           LeftIndent:  longint;
           RightIndent: longint;

           { Tabs }
           Tab:         TList;

           { Colspan }
           colspan:  Boolean;
           colcount: integer;

           property  TabCount:    integer read FTabCount write setTabCount;

           constructor Create;
           destructor  Destroy; override;

           procedure AssignTo(sender: TObject);
           procedure Assign(sender: TObject);
           procedure AssignFont(sender: TObject);
           procedure AssignIndent(sender: TObject);
           procedure AssignTab(sender: TObject);
           procedure AssignTabStops(tabs: string);
     end;

     TParseResults =class(TObject)
     private
     protected
     public
           fontList:       TList;
           tabList:        TList;
           indentList:     TList;

           constructor Create;
           destructor  Destroy; override;

           procedure Clear;
           procedure AssignTo(sender: TObject);
           procedure Assign(sender: TObject);
     end;


     function PixelLength(canvas: TCanvas;
                          var aResult: TParseResult; var aResults: TParseResults;
                          const text: string; var index: integer; var highest: integer): integer;
     function ParseText(const text: string; var index: integer;
                        var aResult: TParseResult; var aResults: TParseResults; var tag: integer): string;

     function ParseTag(tag: integer; const text: string; index: integer;
                       var aResult: TParseResult; var aResults: TParseResults): integer;
     function GetTagLen(const text:string; tag: integer; index: integer): integer;
     function GetParamLen(const text: string; param: integer; index: integer): integer;
     function NextNamedTag(tag: integer; const text: string; index: integer): integer;
     function NextNamedParam(param: integer; const text: string; index: integer): integer;
     function NextTag(const text: string; var tag: integer; index: integer): integer;
     function NextParam(const text: string; var param: integer; index: integer): integer;
     function CheckLimits(limit: TRect; var test: TRect; var overLimit: TRect): Boolean;

implementation

constructor TParseResults.Create;
begin
     inherited;

     fontList :=   TList.Create;
     tabList :=    TList.Create;
     indentList := TList.Create;

     fontList.Clear;
     tabList.Clear;
     indentList.Clear;
end;

destructor  TParseResults.Destroy;
begin
     Clear;

     fontList.Destroy;
     tabList.Destroy;
     indentList.Destroy;

     inherited;
end;

procedure TParseResults.Clear;
var
   x: integer;
begin
   for x := 0 to (tabList.count - 1) do
        if tabList.Items[x] <> nil then
           TParseResult(tabList.Items[x]).Destroy;

   for x := 0 to (fontList.count - 1) do
        if fontList.Items[x] <> nil then
           TParseResult(fontList.Items[x]).Destroy;

   for x := 0 to (indentList.count - 1) do
        if indentList.Items[x] <> nil then
           TParseResult(indentList.Items[x]).Destroy;

   fontList.Clear;
   tabList.Clear;
   indentList.Clear;
end;

procedure  TParseResults.AssignTo(sender: TObject);
var
   x: integer;
begin
     if sender is TParseResults then
     begin
          TParseResults(sender).Clear;
          TParseResults(sender).TabList.count :=    TabList.count;
          TParseResults(sender).fontList.count :=   fontList.count;
          TParseResults(sender).indentList.count := indentList.count;

          for x := 0 to (tabList.count - 1) do
          begin
               TParseResults(sender).TabList[x] := TParseResult.Create;
               TParseResult(TParseResults(sender).TabList[x]).Assign(tabList[x]);
          end;

          for x := 0 to (indentList.count - 1) do
          begin
               TParseResults(sender).indentList[x] := TParseResult.Create;
               TParseResult(TParseResults(sender).indentList[x]).Assign(indentList[x]);
          end;

          for x := 0 to (fontList.count - 1) do
          begin
               TParseResults(sender).fontList[x] := TParseResult.Create;
               TParseResult(TParseResults(sender).fontList[x]).Assign(fontList[x]);
          end;

     end
end;

procedure  TParseResults.Assign(sender: TObject);
var
   x: integer;
begin
     if sender is TParseResults then
     begin
          Clear;
          TabList.count :=    TParseResults(sender).TabList.count;
          fontList.count :=   TParseResults(sender).fontList.count;
          indentList.count := TParseResults(sender).indentList.count;

          for x := 0 to (TParseResults(sender).tabList.count - 1) do
          begin
               TabList[x] := TParseResult.Create;
               TParseResult(TabList[x]).Assign(TParseResult(TParseResults(sender).tabList[x]));
          end;

          for x := 0 to (TParseResults(sender).indentList.count - 1) do
          begin
               TParseResults(sender).indentList[x] := TParseResult.Create;
               TParseResult(indentList[x]).Assign(TParseResult(TParseResults(sender).indentList[x]));
          end;

          for x := 0 to (TParseResults(sender).fontList.count - 1) do
          begin
               fontList[x] := TParseResult.Create;
               TParseResult(fontList[x]).Assign(TParseResult(TParseResults(sender).fontList[x]));
          end;

     end
end;


constructor TParseResult.Create;
begin
     Tab := TList.Create;
     Tab.Clear;

     LineBreak := False;
     tabulator := False;
     Colspan :=   False;
end;

destructor  TParseResult.Destroy;
begin
     Tab.Destroy;
end;


procedure  TParseResult.SetTabCount(value: integer);
begin
     Tab.Count := value;
     FTabCount := value;
end;

procedure TParseResult.AssignTabStops(tabs: string);
var
   i,len: integer;
   rest, value: string;
begin
     rest := tabs + ',';
     len :=  pos(',', rest) - 1;

     if len < 0 then
        len := length(rest);

     i := 0;

     while (rest <> '') and (len >= 0) do
     begin
          value := Copy(rest, 1, len);
          rest :=  Copy(rest, len + 2, length(rest));
          len :=   pos(',', rest) - 1;

          if i > tabCount - 1 then
             tabCount := i + 1;

          tab[i] := Pointer(StrToIntDef(value, Integer(tab[i])));

          if (len < 0) and (rest <> '') then
             len := length(rest);

          i := i + 1;
     end;

     tabCount := i;
end;

procedure  TParseResult.AssignTo(sender: TObject);
var
   x: integer;
begin
     if sender is TFont then
     begin
          if (TFont(sender).style <> style) then
             TFont(sender).style := style;

          if (TFont(sender).color <> color) then
             TFont(sender).color := color;

          if (TFont(sender).name <> name) then
             TFont(sender).name := name;

          if (TFont(sender).CharSet <> CharSet) then
             TFont(sender).CharSet := CharSet;

          if (TFont(sender).Height <> Height) then
             TFont(sender).Height := Height;

          if (TFont(sender).Size <> Size) then
             TFont(sender).Size := size;

          if (TFont(sender).Pitch <> Pitch) then
             TFont(sender).Pitch := Pitch;

          if (TFont(sender).PixelsPerInch <> PixelsPerInch) then
             TFont(sender).PixelsPerInch := PixelsPerInch;
     end
     else
     if sender is TTextAttributes then
     begin
          if (TTextAttributes(sender).style <> style) then
             TTextAttributes(sender).style :=  style;
          if (TTextAttributes(sender).color <> color) then
             TTextAttributes(sender).color :=  color;
          if (TTextAttributes(sender).name <> name) then
             TTextAttributes(sender).name :=  name;
          if (TTextAttributes(sender).CharSet <> CharSet) then
             TTextAttributes(sender).CharSet :=  CharSet;
          if (TTextAttributes(sender).Height <> Height) then
             TTextAttributes(sender).Height :=  Height;
          if (TTextAttributes(sender).Size <> Size) then
             TTextAttributes(sender).Size :=  size;
          if (TTextAttributes(sender).Pitch <> Pitch) then
             TTextAttributes(sender).Pitch :=  Pitch;
     end
     else
     if sender is TParaAttributes then
     begin
          case halign of
               alLeft:
                           if (TParaAttributes(sender).Alignment <> taLeftJustify) then
                              TParaAttributes(sender).Alignment :=  taLeftJustify;
               alCenter:
                           if (TParaAttributes(sender).Alignment <> taCenter) then
                              TParaAttributes(sender).Alignment :=  taCenter;

               alRight:    if (TParaAttributes(sender).Alignment <> taRightJustify) then
                              TParaAttributes(sender).Alignment :=  taRightJustify;
          end;

          if (TParaAttributes(sender).FirstIndent <> FirstIndent) then
             TParaAttributes(sender).FirstIndent :=  FirstIndent;

          if (TParaAttributes(sender).LeftIndent <> LeftIndent) then
             TParaAttributes(sender).LeftIndent :=  LeftIndent;

          if (TParaAttributes(sender).RightIndent <> RightIndent) then
             TParaAttributes(sender).RightIndent :=  RightIndent;

          if (TParaAttributes(sender).tabCount <> tabCount) then
             TParaAttributes(sender).tabCount :=  TabCount;

          for x:= 0 to tabCount - 1 do
              if (TParaAttributes(sender).Tab[x] <> Integer(tab[x])) then
                 TParaAttributes(sender).Tab[x] :=  Integer(tab[x]);
     end
     else
     if sender is TParseResult then
     begin
          TParseResult(sender).style :=         style;
          TParseResult(sender).color :=         color;
          TParseResult(sender).name :=          name;
          TParseResult(sender).CharSet :=       CharSet;
          TParseResult(sender).Size :=          size;
          TParseResult(sender).Pitch :=         Pitch;
          TParseResult(sender).Height :=        Height;
          TParseResult(sender).PixelsPerInch := PixelsPerInch;

          TParseResult(sender).HAlign :=        HAlign;
          TParseResult(sender).VAlign :=        VAlign;
          TParseResult(sender).FirstIndent :=   FirstIndent;
          TParseResult(sender).LeftIndent :=    LeftIndent;
          TParseResult(sender).RightIndent :=   RightIndent;
          TParseResult(sender).tabCount :=      TabCount;

          for x := 0 to tabCount - 1 do
              TParseResult(sender).Tab[x] := tab[x];
     end;
end;

procedure  TParseResult.Assign(sender: TObject);
var
   x: integer;
begin
     if sender is TFont then
     begin
          style :=         TFont(sender).style;
          color :=         TFont(sender).color;
          name :=          TFont(sender).name;
          CharSet :=       TFont(sender).CharSet;
          Height :=        TFont(sender).Height;
          Size :=          TFont(sender).size;
          Pitch :=         TFont(sender).Pitch;
          PixelsPerInch := TFont(sender).PixelsPerInch;
     end
     else
     if sender is TTextAttributes then
     begin
          style :=   TTextAttributes(sender).style;
          color :=   TTextAttributes(sender).color;
          name :=    TTextAttributes(sender).name;
          CharSet := TTextAttributes(sender).CharSet;
          Height :=  TTextAttributes(sender).Height;
          Size :=    TTextAttributes(sender).size;
          Pitch :=   TTextAttributes(sender).Pitch;
     end
     else
     if sender is TParaAttributes then
     begin
          case TParaAttributes(sender).Alignment of
               taLeftJustify:  halign := alLeft;
               taCenter:       halign := alCenter;
               taRightJustify: halign := alRight;
          end;

          FirstIndent :=  TParaAttributes(sender).FirstIndent;
          LeftIndent :=   TParaAttributes(sender).LeftIndent;
          RightIndent :=  TParaAttributes(sender).RightIndent;
          tabCount :=     TParaAttributes(sender).TabCount;

          for x := 0 to tabCount - 1 do
              tab[x] := Pointer(TParaAttributes(sender).Tab[x]);
     end
     else
     if sender is TParseResult then
     begin
          style :=         TParseResult(sender).style;
          color :=         TParseResult(sender).color;
          name :=          TParseResult(sender).name;
          CharSet :=       TParseResult(sender).CharSet;
          Size :=          TParseResult(sender).size;
          Pitch :=         TParseResult(sender).Pitch;
          Height :=        TParseResult(sender).Height;
          PixelsPerInch := TParseResult(sender).PixelsPerInch;

          HAlign :=        TParseResult(sender).HAlign;
          VAlign :=        TParseResult(sender).VAlign;
          FirstIndent :=   TParseResult(sender).FirstIndent;
          LeftIndent :=    TParseResult(sender).LeftIndent;
          RightIndent :=   TParseResult(sender).RightIndent;
          tabCount :=      TParseResult(sender).TabCount;

          for x := 0 to tabCount - 1 do
              Tab[x] := TParseResult(sender).tab[x];

          lineBreak :=  False;
     end;
end;

procedure  TParseResult.AssignFont(sender: TObject);
begin
     if sender is TFont then
     begin
          style :=         TFont(sender).style;
          color :=         TFont(sender).color;
          name :=          TFont(sender).name;
          CharSet :=       TFont(sender).CharSet;
          Height :=        TFont(sender).Height;
          Size :=          TFont(sender).size;
          Pitch :=         TFont(sender).Pitch;
          PixelsPerInch := TFont(sender).PixelsPerInch;
     end
     else
     if sender is TTextAttributes then
     begin
          style :=   TTextAttributes(sender).style;
          color :=   TTextAttributes(sender).color;
          name :=    TTextAttributes(sender).name;
          CharSet := TTextAttributes(sender).CharSet;
          Height :=  TTextAttributes(sender).Height;
          Size :=    TTextAttributes(sender).size;
          Pitch :=   TTextAttributes(sender).Pitch;
     end
     else
     if sender is TParseResult then
     begin
          style :=         TParseResult(sender).style;
          color :=         TParseResult(sender).color;
          name :=          TParseResult(sender).name;
          CharSet :=       TParseResult(sender).CharSet;
          Size :=          TParseResult(sender).size;
          Pitch :=         TParseResult(sender).Pitch;
          Height :=        TParseResult(sender).Height;
          PixelsPerInch := TParseResult(sender).PixelsPerInch;
     end;
end;

procedure  TParseResult.AssignIndent(sender: TObject);
begin
     if sender is TParaAttributes then
     begin
          case TParaAttributes(sender).Alignment of
               taLeftJustify:  halign := alLeft;
               taCenter:       halign := alCenter;
               taRightJustify: halign := alRight;
          end;

          FirstIndent :=  TParaAttributes(sender).FirstIndent;
          LeftIndent :=   TParaAttributes(sender).LeftIndent;
          RightIndent :=  TParaAttributes(sender).RightIndent;
     end
     else
     if sender is TParseResult then
     begin
          HAlign :=       TParseResult(sender).HAlign;
          VAlign :=       TParseResult(sender).VAlign;
          FirstIndent :=  TParseResult(sender).FirstIndent;
          LeftIndent :=   TParseResult(sender).LeftIndent;
          RightIndent :=  TParseResult(sender).RightIndent;
     end;
end;

procedure  TParseResult.AssignTab(sender: TObject);
var
   x: integer;
begin
     if sender is TParaAttributes then
     begin
          tabCount :=  TParaAttributes(sender).TabCount;

          for x := 0 to tabCount - 1 do
              tab[x] := Pointer(TParaAttributes(sender).Tab[x]);
     end
     else
     if sender is TParseResult then
     begin
          tabCount :=  TParseResult(sender).TabCount;

          for x := 0 to tabCount - 1 do
              Tab[x] := TParseResult(sender).tab[x];
     end;
end;

function PixelLength(canvas: TCanvas;
                     var aResult: TParseResult; var aResults: TParseResults;
                     const text: string; var index: integer; var highest: integer): integer;
var
   height: integer;
   width:  integer;
   temp: string;
   tag: integer;
   stop: Boolean;
   totalLen, len: integer;
   tmpFont: TFont;
   orgFont: TFont;
   tmpResult: TParseResult;
   tmpResults:   TParseResults;
   label exit;
begin
   totalLen := 0;
   if (text='') then
      goto exit;

   tmpResults := TParseResults.Create;
   tmpResults.Clear;

   tmpResults.Assign(aResults);

   tmpResult := TParseResult.Create;
   tmpResult.Assign(aResult);

   orgFont := TFont.Create;
   tmpFont := TFont.Create;
   orgFont.Assign(canvas.font);

   stop :=  False;
   len :=   length(text);

   while (stop = False) do
   begin
        // temp2 :=  Copy(text, index + 1, length(text) - index);
        temp := ParseText(text, index, tmpResult, tmpResults, tag);

        {if (GetTagLen(temp2, LEFT_TAG) <> 0) OR
           (GetTagLen(temp2, RIGHT_TAG) <> 0) OR
           (GetTagLen(temp2, CENTER_TAG) <> 0) or
           (GetTagLen(temp2, BELOW_TAG) <> 0) OR
           (GetTagLen(temp2, ABOVE_TAG) <> 0) OR
           (GetTagLen(temp2, MIDDLE_TAG) <> 0) then }
        if (tag = LEFT_TAG) OR
           (tag = RIGHT_TAG) OR
           (tag = CENTER_TAG) or
           (tag = BELOW_TAG) OR
           (tag = ABOVE_TAG) OR
           (tag = MIDDLE_TAG) then
            stop := True
        else
        begin
             if (temp <> '') then
             begin
                  tmpResult.AssignTo(canvas.font);
                  height :=   canvas.TextHeight(temp);
                  width :=    canvas.TextWidth(temp);
                  totalLen := totalLen + width;
                  if height > highest then highest := height;
             end;
        end;

        if (index > len) then stop := TRUE;
   end;

   canvas.font := orgFont;

   tmpFont.Destroy;
   orgFont.Destroy;
   tmpResults.Destroy;
   tmpResult.Destroy;

exit:
   Result := totalLen;
end;

function ParseText(const text: string; var index: integer;
                   var aResult: TParseResult; var aResults: TParseResults; var tag: integer): string;
var
   retVal: string;
   // tmp: string;
   tagpos: integer;
begin
     // tmp :=  Copy(text, index + 1, Length(text) - index);
     tagpos := NextTag(text, tag, index);        //<TAGin sijainti TEXT´issä INDEX JÄLKEEN (Kommentti: DEVELOPER1 5.0.0)

     aResult.LineBreak := False;

     if (tagpos = 1) then
     begin
          retval := '';
          index :=  index + ParseTag(tag, text, index, aResult, aResults);
     end
     else
     begin
          retval := Copy(text, index , tagpos - 1);
          index :=  index + Length(retval);
     end;

     result := retval;
end;

function ParseTag(tag: integer; const text: string; index: integer;
                  var aResult: TParseResult; var aResults: TParseResults): integer;
var
   tmp2: string;
   tmpResult: TParseResult;
   taglen: integer;
   totalLen: integer;
begin
          aResult.lineBreak := False;
          aResult.tabulator := False;
          aResult.colspan :=  False;

          case tag of
          COLSPAN_START_TAG:
          begin
               tagLen :=    GetTagLen(text, COLSPAN_START_TAG, index);
               totalLen :=  tagLen;
               index :=     index + taglen;

               tagLen :=    GetParamLen(text, COLSPAN_COLCOUNT_PARAM, index);
               totalLen :=  tagLen + totalLen;
               index :=     index + taglen;

               tagLen :=  NextNamedParam(COLSPAN_START_PARAM, text, index);

               totalLen := totalLen + tagLen - 1;

               tmp2 := Copy(text, index, tagLen - 1);
               if (tmp2 <> '') then
               begin
                  aResult.Colspan :=  TRUE;
                  aResult.colcount := StrToInt(tmp2);
               end;

               // index :=  index + taglen + 1;

               Result := totalLen + length(params[COLSPAN_START_PARAM]);
          end;

          LINE_BREAK:
          begin
               aResult.lineBreak := True;
               Result := GetTagLen(text, LINE_BREAK, index);
          end;

          ABOVE_TAG:
          begin
               aResult.VAlign := alAbove;
               Result := GetTagLen(text, ABOVE_TAG, index);
          end;

          BELOW_TAG:
          begin
               aResult.VAlign := alBelow;
               Result := GetTagLen(text, BELOW_TAG, index);
          end;

          MIDDLE_TAG:
          begin
               aResult.VAlign := alMiddle;
               Result := GetTagLen(text, MIDDLE_TAG, index);
          end;

          LEFT_TAG:
          begin
               aResult.HAlign := alLeft;
               Result := GetTagLen(text, LEFT_TAG, index);
          end;

          RIGHT_TAG:
          begin
               aResult.HAlign := alRight;
               Result := GetTagLen(text, RIGHT_TAG, index);
          end;

          CENTER_TAG:
          begin
               aResult.HAlign := alCenter;
               Result := GetTagLen(text, CENTER_TAG, index);
          end;

          FONT_BOLD_START:
          begin
               aResult.style := aResult.style + [fsBold];
               Result := GetTagLen(text, FONT_BOLD_START, index);
          end;

          FONT_BOLD_END:
          begin
               aResult.style := aResult.style - [fsBold];
               Result := GetTagLen(text, FONT_BOLD_END, index);
          end;

          FONT_ITALIC_START:
          begin
               aResult.style := aResult.style + [fsItalic];
               Result := GetTagLen(text, FONT_ITALIC_START, index);
          end;

          FONT_ITALIC_END:
          begin
               aResult.style := aResult.style - [fsItalic];
               Result := GetTagLen(text, FONT_ITALIC_END, index);
          end;

          FONT_UNDERLINE_START:
          begin
               aResult.style := aResult.style + [fsUnderline];
               Result := GetTagLen(text, FONT_UNDERLINE_START, index);
          end;

          FONT_UNDERLINE_END:
          begin
               aResult.style := aResult.style - [fsUnderline];
               Result := GetTagLen(text, FONT_UNDERLINE_END, index);
          end;

          FONT_STRIKEOUT_START:
          begin
               aResult.style := aResult.style + [fsStrikeOut];
               Result := GetTagLen(text, FONT_STRIKEOUT_START, index);
          end;

          FONT_STRIKEOUT_END:
          begin
               aResult.style := aResult.style - [fsStrikeOut];
               Result := GetTagLen(text, FONT_STRIKEOUT_END, index);
          end;

          TAB_TAG:
          begin
               aResult.tabulator := True;
               Result := GetTagLen(text, TAB_TAG, index);
          end;

          FONT_END_TAG:
          begin
               if (aResults.fontList.Count > 0) then
                  aResult.AssignFont(aResults.fontList.Last);

               if (aResults.fontList.Count > 0) then
               begin
                    TParseResult(aResults.fontList.Last).Destroy;
                    aResults.fontList.Delete(aResults.fontList.count - 1);
               end;

               Result := GetTagLen(text, FONT_END_TAG, index);
          end;

          INDENT_END_TAG:
          begin
               if (aResults.IndentList.Count > 0) then
                  aResult.AssignIndent(aResults.IndentList.Last);

               if (aResults.IndentList.Count > 0) then
               begin
                    TParseResult(aResults.IndentList.Last).Destroy;
                    aResults.IndentList.Delete(aResults.IndentList.count - 1);
               end;

               aResult.LineBreak := False;

               Result := GetTagLen(text, INDENT_END_TAG, index);
          end;

          TAB_END_TAG:
          begin
               if (aResults.TabList.Count > 0) then
                  aResult.AssignTab(aResults.TabList.Last);

               if (aResults.TabList.Count > 0) then
               begin
                    TParseResult(aResults.TabList.Last).Destroy;
                    aResults.TabList.Delete(aResults.TabList.count - 1);
               end;

               Result := GetTagLen(text, TAB_END_TAG, index);
          end;

          FONT_START_TAG:
          begin
               tmpResult := TParseResult.Create;
               tmpResult.AssignFont(aResult);
               aResults.fontList.Add(tmpResult);

               tagLen :=   GetTagLen(text, FONT_START_TAG, index);
               totalLen := tagLen;
               index :=    index + taglen;

               tagLen :=   GetParamLen(text, FONT_NAME_PARAM, index);
               totalLen := tagLen + totalLen;
               index :=    index + taglen;
               tagLen :=   NextNamedParam(FONT_SIZE_PARAM, text, index);

               totalLen :=  totalLen + tagLen - 1;

               tmp2 :=  Copy(text, index, tagLen - 1);
               if (tmp2 <> '') then
                  aResult.Name := tmp2;

               index := index + taglen - 1;

               tagLen :=   GetParamLen(text, FONT_SIZE_PARAM, index);
               totalLen := totalLen + tagLen;
               index :=    index + taglen;

               tagLen :=  NextNamedParam(FONT_COLOR_PARAM, text, index);

               totalLen := totalLen + tagLen - 1;

               tmp2 := Copy(text, index, tagLen - 1);
               if (tmp2 <> '') then
                  aResult.Size := StrToIntDef(tmp2, aResult.Size);

               index :=    index + taglen - 1;
               tagLen :=   GetParamLen(text, FONT_COLOR_PARAM, index);
               totalLen := totalLen + tagLen;
               index :=    index + taglen;

               tagLen :=   NextNamedParam(FONT_START_PARAM, text, index);
               totalLen := totalLen + tagLen - 1;

               tmp2 :=  Copy(text, index, tagLen - 1);
               if (tmp2 <> '') then
                  aResult.Color := StrToIntDef(tmp2, aResult.Color);

               // index :=  index + taglen - 1;

               Result := totalLen + length(params[FONT_START_PARAM]);
          end;

          INDENT_START_TAG:
          begin
               tmpResult := TParseResult.Create;
               tmpResult.AssignIndent(aResult);
               aResults.indentList.Add(tmpResult);

               aResult.LineBreak := True;

               tagLen :=   GetTagLen(text, INDENT_START_TAG, index);
               totalLen := tagLen;
               index :=    index + taglen;

               tagLen :=   GetParamLen(text, INDENT_FIRST_PARAM, index);
               totalLen := tagLen + totalLen;
               index :=    index + taglen;
               tagLen :=   NextNamedParam(INDENT_LEFT_PARAM, text, index);

               totalLen := totalLen + tagLen - 1;

               tmp2 :=  Copy(text, index, tagLen - 1);
               if (tmp2 <> '') then
                  aResult.FirstIndent := StrToIntDef(tmp2, aResult.FirstIndent);

               index :=    index + taglen - 1;
               tagLen :=   GetParamLen(text, INDENT_LEFT_PARAM, index);
               totalLen := totalLen + tagLen;
               index :=    index + taglen;
               tagLen :=   NextNamedParam(INDENT_RIGHT_PARAM, text, index);

               totalLen := totalLen + tagLen - 1;

               tmp2 :=  Copy(text, index, tagLen - 1);
               if (tmp2 <> '') then
                  aResult.LeftIndent := StrToIntDef(tmp2, aResult.LeftIndent);

               index :=    index + taglen - 1;
               tagLen :=   GetParamLen(text, INDENT_RIGHT_PARAM, index);
               totalLen := totalLen + tagLen;
               index :=    index + taglen;
               tagLen :=   NextNamedParam(INDENT_START_PARAM, text, index);
               totalLen := totalLen + tagLen - 1;

               tmp2 :=  Copy(text, index, tagLen - 1);
               if (tmp2 <> '') then
                  aResult.RightIndent := StrToIntDef(tmp2, aResult.RightIndent);
               // index := index + taglen - 1;

               Result := totalLen + length(params[INDENT_START_PARAM]);
          end;

          TAB_START_TAG:
          begin
               tmpResult := TParseResult.Create;
               tmpResult.AssignTab(aResult);
               aResults.tabList.Add(tmpResult);

               tagLen :=   GetTagLen(text, TAB_START_TAG, index);
               totalLen := tagLen;
               index :=    index + taglen;

               tagLen :=   GetParamLen(text, TAB_STOPS_PARAM, index);
               totalLen := tagLen + totalLen;
               index :=    index + taglen;

               tagLen :=  NextNamedParam(TAB_START_PARAM, text, index);

               totalLen := totalLen + tagLen - 1;

               tmp2 := Copy(text, index, tagLen - 1);
               if (tmp2 <> '') then
                  aResult.AssignTabStops(tmp2);

               //index := index + taglen - 1;

               Result := totalLen + length(params[TAB_START_PARAM]);
          end
          else
              Result := 0;
     end;
end;


function GetTagLen(const text: string; tag: integer; index: integer): integer;
var
   taglen: integer;
begin
     tagLen := tagsLen[tag];

     if Copy(text, index, tagLen) = tags[tag] then
        Result := tagLen
     else
        Result := 0;
end;


function GetParamLen(const text: string; param: integer; index: integer): integer;
var
   len: integer;
begin
     len := paramsLen[param];

     if Copy(text, index, len) =params[param] then
        Result := len
     else
        Result := 0;
end;

function NextNamedTag(tag:integer; const text: string; index: integer): integer;
var
   position: integer;
   endpos:   integer;
   retVal:   integer;
   tag2: integer;
begin
     RetVal := 0;
     endpos := NextTag(text, tag2, index);

     position := Pos(tags[tag], text[index]);
     if (position <> 0) and (position < endpos) then RetVal := position;

     result := retval;
end;

function NextNamedParam(param: integer; const text: string; index: integer): integer;
var
   endpos:   integer;
   tag2: integer;
begin
     endpos := NextParam(text, tag2, index);
     result := endpos;
end;

function NextTag(const text: string;  var tag: integer;  index: integer): integer;
label exit;
var
   pointer: PChar;
   position: integer;
   startpos: integer;
   x, len, tmpIndex: integer;
   tmp2, tmp, restOfText: string;
begin
     tag := -1;
     if (tagList = nil) then
     begin
          tagList := TStringList.Create;

          tagList.Sorted := TRUE;
          longest := 0;

          for x:=0 to TAG_COUNT - 1 do
          begin
               len := length(tags[x]);
               if (len > longest) then longest := len;

               pointer := addr(String(tags[x])[2]);
               tmp :=  string(pointer);
               tagList.AddObject(tmp, TObject(x));
               tagsLen[x] := len;
          end;

          tagList.sort;
     end;

     if (paramList = nil) then
     begin
          paramList := TStringList.Create;

          paramList.Sorted := TRUE;
          longestParam :=  0;

          for x:=0 to PARAM_COUNT - 1 do
          begin
               len := length(params[x]);
               if (len > longestParam) then longestParam := len;
               paramList.AddObject(params[x], TObject(x));
               paramsLen[x] := len;
          end;

          paramList.sort;
     end;

     len := length(text);
     startpos := len - index + 2;

     //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,DEVELOPER1
    {if startpos>len                  //< +3.0.3 DEVELOPER1:  Tällä ohitetaan ERangeError 'Range check error'.,
        then goto exit;               //                mutta jättää TAGit näkyviin textiin !!!!!!!!!!!!!}

 {    indu := index;                   //<,,+3.0.3
     if indu<=0
     then indu := 1
     else if indu>len
     then goto exit;

   //pointer := addr(text[index]);    //< Alp. DEVELOPER2
     pointer := addr(text[indu]);     //< 3.0.3 DEVELOPER1     }

     //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Loput ALKUPERÄISIÄ = DEVELOPER2,,,,,,,,,,,,,,,,,,,,,,,,

      //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,DEVELOPER1
    {if startpos>len                  //< +3.0.3 DEVELOPER1:  Tällä ohitetaan ERangeError 'Range check error'.,
        then goto exit;               //                mutta jättää TAGit näkyviin textiin !!!!!!!!!!!!!}

     if index <= 0
     then
         index := 1
     else if index>len
     then
     begin                           // Index on suuurempi kuin merkkijono pituus, joten funktio voidaan lopettaa
         startpos := len + 1;        // Startpos täytyy olla pituus + 1, jotta kutsuvat funktiot
                                     // huomaavat olevansa tekstin lopussa.
         goto exit;                  // Lisätty goto, jotta funktion suorittaminen loppuu 15.11.2000/DEVELOPER2
     end;

     pointer := addr(text[index]);    //< Alp. DEVELOPER2
     //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,Loput ALKUPERÄISIÄ = DEVELOPER2,,,,,,,,,,,,,,,,,,,,,,,,

     restOfText :=  string(pointer);

     len :=length(restOfText);

     if (len > 0) and  (restOfText[1] = '<') then
     begin
        position := 1;
        startpos := position;
     end
     else
     begin
         position := Pos('<', restOfText);
         if (position = 0) then
            goto exit;

         startpos := position;

         goto exit;
     end;

    { position := Pos('>', text);

     if (position = 0) then
     begin
          startpos := startpos + 1;
          goto exit;
     end;

     endpos := position;
      tmp2 := Copy(text, startpos, endpos - startpos + 1);
   {  if (tagList.Find(tmp2, tmpIndex) = TRUE) then
     begin
          tag := Integer(tagList.objects[tmpIndex]);
          goto exit;
     end;

     x:= startpos;
     tmp2 := '';

     while ((x <= endpos) and ((x - startpos) < longest)) do
     begin
          tmp2 := tmp2 + text[x];
          x:= x + 1;
          if (tagList.Find(tmp2, tmpIndex) = TRUE) then
          begin
             tag := Integer(tagList.objects[tmpIndex]);
             goto exit;
          end;
     end; }

     pointer := Addr(restOfText[2]);
     restOfText :=  string(pointer);

     if (tagList.Find(restOfText, tmpIndex) = TRUE) then
     begin
          tag := Integer(tagList.objects[tmpIndex]);
          goto exit;
     end;

     x := 0;
     tmp2 := '<' + restOfText;
     while (x < TAG_COUNT) do
     begin
          if (SysUtils.StrLComp(PChar(Addr(String(tags[x])[1])), PChar(Addr(tmp2[1])), tagsLen[x]) = 0) then
          begin
               tag := x;
               goto exit;
          end;
          x := x + 1;
     end;

     startpos := startpos + 1;

exit:
     Result := startpos;
end;

function NextParam(const text: string; var param: integer; index: integer): integer;
var
   pointer: PChar;
   position: integer;
   startpos, endpos:   integer;
   x, len, next: integer;
   tmp2, restOfText: string;
   label exit;
begin
     param := -1;
     if (tagList = nil) then
     begin
          tagList := TStringList.Create;

          tagList.Sorted := TRUE;
          longest := 0;

          for x := 0 to TAG_COUNT - 1 do
          begin
               len := length(tags[x]);
               if (len > longest) then longest := len;
               tagList.AddObject(tags[x], TObject(len));
          end;
     end;

     if (paramList = nil) then
     begin
          paramList := TStringList.Create;

          paramList.Sorted := TRUE;
          longestParam :=  0;

          for x:=0 to PARAM_COUNT - 1 do
          begin
               len := length(params[x]);
               if (len > longestParam) then longestParam := len;
               paramList.AddObject(params[x], TObject(len));
          end;
     end;

     pointer := addr(text[index]);
     restOfText :=    string(pointer);

     startpos := 0;

     position := Pos('>', restOfText);

     if (position = 0) then
        goto exit;

     endpos :=  position;
     startpos := endpos;
     tmp2 := Copy(restOfText, 1, endpos);

     for x := 0 to paramList.count - 1 do
     begin
          next := Pos(paramList[x], tmp2);

          if (next <> 0) and (next < startpos) then
          begin
             param := Integer(paramList.objects[x]);
             startpos := next;
          end;
     end;

exit:
     Result := startpos;
end;

{ Tests if test-TRect fits inside limit-TRect. Returns True or False.
  Test-TRect will be resized so that it will fit to limit-TRect.
  OverLimit-TRect tells how to resize limit-TRect that test-TRect would
  fit to limit-TRect. }
function CheckLimits(limit: TRect; var test: TRect; var overLimit: TRect): Boolean;
var
   inLimits: Boolean;
begin
     inLimits :=  True;

     if (overLimit.Top > test.Top - limit.Top) then
        overLimit.Top := test.Top - limit.Top;

     if (test.Top < limit.Top) then
     begin
        test.Top := limit.Top;
        inLimits := False;
     end;

     if (test.Top > limit.Bottom) then
     begin
        test.Top := limit.Bottom;

        if (overLimit.Bottom < test.Top - limit.Bottom) then
           overLimit.Bottom := test.Top - limit.Bottom;

        inLimits := False;
     end;

     if (overLimit.Bottom < test.Bottom - limit.Bottom) then
        overLimit.Bottom :=  test.Bottom - limit.Bottom;

     if (test.Bottom > limit.Bottom) then
     begin
        test.Bottom := limit.Bottom;
        inLimits :=    False;
     end;

     if (test.Bottom < limit.Top) then
     begin
        test.Bottom := limit.Top;

        if (overLimit.Top > test.Bottom - limit.Top) then;
           overLimit.Top :=  test.Bottom - limit.Top;

        inLimits :=  False;
     end;

     if (overLimit.Left > test.Left - limit.Left) then
        overLimit.Left :=  test.Left - limit.Left;

     if (test.left < limit.Left) then
     begin
        test.Left := limit.Left;
        inLimits :=  False;
     end;

     if (test.left > limit.Right) then
     begin
        test.Left := limit.Right;

        if (overLimit.Right < test.Left - limit.Left) then
           overLimit.Right :=  test.Left - limit.Right;

        inLimits :=  False;
     end;

     if (overLimit.Right < test.Right - limit.Right) then
      overLimit.Right :=  test.Right - limit.Right;

     if (test.Right > limit.Right) then
     begin
        test.Right := limit.Right;
        inLimits :=  False;
     end;

     if (test.Right < limit.Left) then
     begin
        test.Right := limit.Left;

        if (overLimit.Left > test.Right - limit.Left) then
           overLimit.Left :=  test.Right - limit.Left;

        inLimits :=  False;
     end;

     result := inLimits;
end;
end.






