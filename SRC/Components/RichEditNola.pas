{
* Copyright (c) 2020, Reijo Pursiainen, Hannu Pursiainen
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of Reijo Pursiainen, Hannu Pursiainen nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY REIJO PURSIAINEN, HANNU PURSIAINEN AND
* CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
* BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL REIJO PURSIAINEN,
* HANNU PURSIAINEN AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
}

///////////////////////////////////////////////////////////////////////////////
//
// FileName:  RichEditNola.pas
// Location:  src\components
// Abstract:  RichEdit, jota voidaan ohjata tekstimääreillä (ks. NolaComp.pas).
//
///////////////////////////////////////////////////////////////////////////////
//
// Following fields are automatically generated by the version control system:
//
// $Revision: 1.3 $
//     $Date: 2005/10/09 13:59:21 $
//
///////////////////////////////////////////////////////////////////////////////
//
// Change Log. Old log entries can be removed by deleting them.
// $Log: RichEditNola.pas,v $
// Revision 1.3  2005/10/09 13:59:21  DEVELOPER2
// Reijolta 26.9.2005
//
// 
// 6     31.07.02 9:46 DEVELOPER2
// - New file header.
// - String parameters to consts
//
// 1    19.07.01 18:50 DEVELOPER1 5.0.0
// Lisätty SYMBOL -merkistön päälle"kytkentä" -> CharSet := SYMBOL_CHARSET;

unit RichEditNola;

interface

uses
  Windows, Messages, SysUtils, Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs,
  Vcl.StdCtrls, Vcl.ComCtrls, nolaComp, RichEdit, inifiles, Vcl.Printers, System.UITypes;

type
  TRichEditNola = class(TRichEdit)
  private
    { Private declarations }
    currResult: TParseResult;
    results:    TParseResults;
    firstTime:  Boolean;

   {constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;                     //<' Siirretty PUBLICiin 3.0.3 :ssa}

    procedure InsertText(const value: string);
    procedure InsertTextToDisplay(const value: string);
    procedure SetText(const value: string);
    function  GetText: string;
    procedure Clean;

  protected
    { Protected declarations }
  public
    { Public declarations }
    constructor Create(AOwner: TComponent); override;
    destructor Destroy; override;                     //<' Siirretty PRIVATEsta 3.0.3 :ssa

    procedure AddText(const value: string);
    procedure Print(const Caption: string); override;
    procedure Clear; override;

  published
    { Published declarations }
    property Text: string read GetText write SetText;
  end;

  procedure FontToAttrib(font: TFont; attrib: TTextAttributes);
  procedure AttribToFont(attrib: TTextAttributes; font: TFont);

procedure Register;

implementation

procedure FontToAttrib(font: TFont; attrib: TTextAttributes);
begin
     attrib.style   := font.style;
     attrib.color   := font.color;
     attrib.name    := font.name;
     attrib.CharSet := font.CharSet;
     attrib.Size    := font.size;
     attrib.Pitch   := font.Pitch;
     attrib.Height  := font.Height;
end;

procedure AttribToFont(attrib: TTextAttributes; font: TFont);
begin
     font.style   := attrib.style;
     font.color   := attrib.color;
     font.name    := attrib.name;
     font.CharSet := attrib.CharSet;
     font.Size    := attrib.size;
     font.Pitch   := attrib.Pitch;
     font.Height  := attrib.Height;
end;

procedure Register;
begin
  RegisterComponents('Nola', [TRichEditNola]);
end;

constructor TRichEditNola.Create(AOwner: TComponent);
begin
     inherited;

     firstTime := True;

     results := TParseResults.Create;
     results.Clear;

     currResult   := TParseResult.Create;

     clean;
end;

destructor  TRichEditNola.Destroy;
begin
     Clean;

     currResult.Destroy;
     results.Destroy;

     inherited;
end;

procedure TRichEditNola.Clear;
begin
     Clean;
     inherited clear;
end;

procedure TRichEditNola.Clean;
begin
   results.Clear;

   case alignment of
   taLeftJustify:   currResult.halign := alLeft;
   taRightJustify:  currResult.halign := alRight;
   taCenter:        currResult.halign := alCenter;
   end;

   currResult.Assign(font);
   currResult.Assign(Paragraph);
end;

procedure TRichEditNola.AddText(const value: string);
{var
   tmpFile: TInifile;     }
begin
     {tmpFile := TInifile.Create('d:\home\kai\projects\nola\test.txt');

     tmpfile.WriteString('test', 'test', value); }
     InsertText(value);

     // tmpfile.Free;
end;

procedure TRichEditNola.SetText(const value: string);
begin
     Lines.Text := '';
     Clean;
     InsertTextToDisplay(value);
end;

procedure TRichEditNola.InsertText(const value: string);
var
   x, len: integer;
   tmp: string;
begin
    tmp := '';
     len := length(value);
     x   := 1;

    while(x <= len) do
     begin
          tmp := Copy(value, x, 200);
          x := x + 200;
          while (x <= len) and (value[x] <> '<') do
          begin
               tmp := tmp + value[x];
               x := x + 1;
          end;

          InsertTextToDisplay(tmp);
     end;
     // InsertTextToDisplay(value);
end;

procedure TRichEditNola.InsertTextToDisplay(const value: string); //DEVELOPER1 5.0.0: Lisätty SYMBOL -merkistön päälle"kytkentä"
var                                                         //-> CharSet := SYMBOL_CHARSET;
   i, tag,x: integer;                                       //sekä Järjestelty THEN BEGIN.. lausesul-
   temp: string;                                            //kurivejä sekä LISÄTTY KOMMENTTEJA.
   table: TStringList;
   intag: boolean;
   tmp: string;
begin
   if (firstTime = True) then
   begin
      Clean;
      SelStart := SelStart - 1;
   end;

   table := TStringList.Create;
   table.sorted := False;

   // Paloitellaan
   tmp := '';
   intag := False;
   for i := 1 to length(value) do
   begin
        if (inTag = TRUE)                     //<Luettiin aikaisemmalla i :n kerralla.
        then begin                            //=Jos INTAG =Kerätään '<' ja '>' välinen mrkjono TMP´iin.
             if (value[i] = '>')              //<Löytyi LOPETUStagi.
             then begin
                  intag := False;
                  tmp := tmp + value[i];

                  if (tmp = tags[LINE_BREAK])
                  then begin
                       table.AddObject(chr(10), TObject(LINE_BREAK));  end
                  else
                  if (tmp = tags[TAB_TAG])
                  then begin
                     table.AddObject(chr(9), TObject(0));  end
                  else
                  begin
                     table.AddObject(tmp, TObject(1));
                  end;
                  tmp := '';
             end
             else
             if (value[i] = '<')              //<Löytyi 2.ALOITUStagi '<' ##########################
             then begin
                  table.AddObject(tmp, TObject(1));
                  tmp := value[i];  end
             else begin
                  tmp := tmp + value[i];
             end;
        end
        else begin
             if (value[i] <> '<')
             then begin
                tmp := tmp + value[i];  end
             else begin                       //<Löytyi ALOITUStagi '<' ############################
                if (tmp <> '') then
                   table.AddObject(tmp, TObject(0)); //<Lisätään kertynytVARSINAINEN MERKKIJONO (tmp) TABLEeen (ilman tageja)
                tmp := value[i];
                inTag := True;
             end;
        end;
   end;

   if (tmp <> '')
   then begin
        if (intag = TRUE)
           then table.AddObject(tmp, TObject(1))
           else table.AddObject(tmp, TObject(0));
   end;

   firstTime := false;

   temp := '';
   for i := 0 to table.count - 1 do
   begin
        tmp := table[i];
        if (table.objects[i] = TObject(0))
        then begin
             temp := temp + tmp;  end
        else
        if (table.objects[i] = TObject(LINE_BREAK))
        then begin
             if (temp <> '') then
                selText := temp;

             SelText := tmp;
             currResult.AssignTo(selAttributes);
             currResult.AssignTo(Paragraph);

             temp := '';  end
        else
        begin
             if (temp <> '') then
                SelText := temp;
             temp := '';

             x := 1;
             while(x <= length(tmp)) do
             begin
                  temp  := ParseText(tmp, x, currResult, results, tag);

                  if currResult.lineBreak = True then
                     SelText := chr(10);

                  currResult.AssignTo(selAttributes);
                  currResult.AssignTo(Paragraph);

                  if  currResult.Tabulator = True then
                      SelText := chr(9);

                  currResult.Tabulator := False;
//DEVELOPER1 5.0.0,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
                  if Pos ('"Symbol"',tmp)>0                     //<,Nyt workkii SYMBOLit tekstissä
                  then selAttributes.CharSet := SYMBOL_CHARSET;
                 {else if Pos ('</f>',tmp)>0                    //<,Ei tarvita, koklattu.
                  then selAttributes.CharSet := ANSI_CHARSET;}
//DEVELOPER1 5.0.0''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''}

                  if (temp <> '') then
                    SelText := temp;
             end;

             temp := '';
        end;
   end;

   if (temp <> '') then
      SelText := temp;

   firstTime := False;
   {i := 1;

   while(i <= length(value)) do
   begin
        // temp2 := Copy(text, i + 1, length(text) - i);
        temp  := ParseText(value, i, currResult, results, tag);
        // temp3 := Copy(text, i + 1, length(text) - i);

        if currResult.lineBreak = True then
            SelText := chr(10);

        currResult.AssignTo(selAttributes);
        currResult.AssignTo(Paragraph);

        if  currResult.Tabulator = True then
            SelText := chr(9);

        currResult.Tabulator := False;

        if (temp <> '') then
        begin
             SelText  := temp;
        end;
   end; }

   table.Free;
end;//InsertTextToDisplay

function  TRichEditNola.GetText: string;
begin
     Result := Lines.Text;
end;

{**********************************************************************
  Print-procedurri on kopioitu suoraan Delphi\source\vcl\comctrls.pas
  tiedostosta sellaisenaan. Tarkoituksena on, että RichEditNola
  käyttäisi tulostukseen NolaPrinters-määrittelyjä
  Printers-määrittelyjen sijasta.

  Proceduuri on kopioitava aina uudelleen uuteen Delphi versioon
  siiryttäessä.

  Windows 2000 Bugi:
  Oireet:      Tulostus jää ikuiseen silmukkaan.
  Korjaus:     Korjataan Service Pack 3:ssa
               Ennen korjauksen ilmestymistä seuraavaa proceduuria
               on muutettu siten, että vain yksi ylimääräinen sivu
               tulostuu. Korjatut kohdat on merkitty W2K_BUG.
               Virhe johtuu siitä, että SendMessage()-funktio
               palauttaa liian pienen indeksin, joka kertoo mikä
               oli viimeinen muotoiltu merkki.
               Korjaus perustuu siihen, että katsotaan onko
               SendMessage()-funktion palauttama indeksi sama tai
               pienempi kuin edellisellä kerralla. Jos näin on,
               oletetaan että kaikki on saatu tulostettu ja lopetetaan.
               Korjaus eí ole täydellinen vaan silti saattaa tulostua
               vielä yksi ylimääräinen sivu.
}
// BEGIN from Delphi\source\vcl\comctrls.pas - DEVELOPER2 2001-09-17
procedure TRichEditNola.Print(const Caption: string);
var
  Range: TFormatRange;
  LastChar, MaxLen, LogX, LogY, OldMap: Integer;
  SaveRect: TRect;
begin
  FillChar(Range, SizeOf(TFormatRange), 0);           //<DEVELOPER1:  Muisti putsataan =Täytetään tyhjillä.
  with Printer, Range do                              //        SizeOf =Muuttujan varaaman muistialueen koko
  begin
    Title := Caption;
    BeginDoc;
    hdc := Handle;
    hdcTarget := hdc;
    LogX := GetDeviceCaps(Handle, LOGPIXELSX);        //<,Palauttaa pixeleinä/inc screen
    LogY := GetDeviceCaps(Handle, LOGPIXELSY);
    if IsRectEmpty(PageRect) then
    begin
      rc.right := PageWidth * 1440 div LogX;
      rc.bottom := PageHeight * 1440 div LogY;
    end
    else begin
      rc.left := PageRect.Left * 1440 div LogX;
      rc.top := PageRect.Top * 1440 div LogY;
      rc.right := PageRect.Right * 1440 div LogX;
      rc.bottom := PageRect.Bottom * 1440 div LogY;
    end;
    rcPage := rc;
    SaveRect := rc;
    LastChar := 0;
    MaxLen := GetTextLen;
    chrg.cpMax := -1;
    // ensure printer DC is in text map mode
    OldMap := SetMapMode(hdc, MM_TEXT);               //,MS:  Print the page by sending EM_FORMATRANGE message.
    SendMessage(Self.Handle, EM_FORMATRANGE, 0, 0);   // flush buffer
    try
      repeat
        rc := SaveRect;
        chrg.cpMin := LastChar;
        LastChar := SendMessage(Self.Handle, EM_FORMATRANGE, 1, Longint(@Range));
        if (LastChar <= chrg.cpMin) then LastChar := -1; // W2K_BUG DEVELOPER2 2001-09-17
        if (LastChar < MaxLen) and (LastChar <> -1) then NewPage;
      until (LastChar >= MaxLen) or (LastChar = -1);
      EndDoc;
    finally
      SendMessage(Self.Handle, EM_FORMATRANGE, 0, 0);    // flush buffer
      SetMapMode(hdc, OldMap);                           // restore previous map mode
    end;
  end;
end;
//''''END from Delphi\source\vcl\comctrls.pas - DEVELOPER2 2001-09-17
end.


