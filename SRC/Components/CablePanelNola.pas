{
* Copyright (c) 2020, Reijo Pursiainen, Hannu Pursiainen
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of Reijo Pursiainen, Hannu Pursiainen nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY REIJO PURSIAINEN, HANNU PURSIAINEN AND
* CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
* BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL REIJO PURSIAINEN,
* HANNU PURSIAINEN AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
}

//
// FileName:  CablePanelNola.pas
// Location:  src\components
// Abstract:  Panel displays cable data in the EdvNjForm and EdvGlobForm.
//===============================================================================================================
// Tehty 6.2.2/DEVELOPER2.  DEVELOPER1:  Kaikki sijoitukset, joissa := on muutettu siten, että ':=' edeltää AINA
// VAIN YKSI VÄLILYÖNTI, esim. '... .Top := ', jolloin sijoituslauseet on mahdollista etsiä tarkasti.
//===============================================================================================================
// MUUTOS DEVELOPER2 JOHTOLUONTIKUVIOIHIN:  +8.0.0  DEVELOPER1:
// Ks. procedure TJohto.WriteEdvJohto(var value: EdvPalstaType);
// CablePanel.InfoButtonOnLeft := false/true //<Muuten poistettaessa Edka[1] tai lisättäessä Sorc[]   InfoButton [1]
//                                           // ei tule oikeaan kohtaan: Src=VasYlös, Edka=Johtoon.
//############################################# Tutkitaan PRC TCablePanelNola.SetLayout´issa.####################
// 8.0.6 muutos:  SetLayout = Indent -korjauksia kun InfoButton´in Width := +1, ks. Johto.PAS rv 863-906 
//===============================================================================================================
///////////////////////////////////////////////////////////////////////////////
//
// Following fields are automatically generated by the version control system:
//
// $Revision: 1.6 $
//     $Date: 2006/04/22 06:33:43 $
//
///////////////////////////////////////////////////////////////////////////////
//
// Change Log. Old log entries can be removed by deleting them.
// $Log: CablePanelNola.pas,v $
// Revision 1.6  2006/04/22 06:33:43  DEVELOPER2
// Korjaus: Kirjanmerkki-napin painaminen ei toiminut, koska nappiin sijoitettiin vahingossa pohjaClick event.
//          DEVELOPER1 22.04.2006:  Lisäsin näkyviin Kain tekemät muutokset, merkintä: //<DEVELOPER2 -8.0.6

// Revision 1.5  2006/04/22 06:08:11  DEVELOPER2
// Reijolta 22.4.2006
//
// Revision 1.4  2006/01/22 09:36:20  DEVELOPER2
// LIsätty OnClick- ja OnDblClick-propertyt
//
// Revision 1.3  2005/10/09 13:57:19  DEVELOPER2
// Reijolta 26.9.2005
//
// 
// 24    22.11.03 10:55 DEVELOPER2
// - Komponenttien sijoittelua parannettu 
// - Komponentin leveyden ja pituuden laskentaa korjattu
// 
// 23    1.08.02 19:31 DEVELOPER2
// Refresh otimized
// 
// 22    31.07.02 9:41 DEVELOPER2
// Several events were added.
// 
// 21    25.06.02 18:50 DEVELOPER2
// Repaint was added.
// 
// 20    16.06.02 14:56 DEVELOPER2
// 7.X.X
//
// 19    24.02.02 19:35 DEVELOPER2
// Bug fix. Using autosize and setting caption of m_ptLabel too early generated
// exceptions in TLabelNola. Label is not autosize and caption is set later.
// 
// 18    24.02.02 12:36 DEVELOPER2
// Bug fix. Text on the last row overlapped the name of the cable.
//
// 17    24.02.02 11:30 DEVELOPER2
// Bug fix. True size of the component was incorrectly calculated so that heigth
// of the component incorrectly increased bit by bit.
//
// 16    24.02.02 11:08 DEVELOPER2
// PT-label heigth is noticed wven if it is not visible -> cable is in correct
// position.

unit CablePanelNola;

interface

uses
  Windows, Messages, SysUtils, Classes, vcl.Graphics, vcl.Controls, vcl.Forms, vcl.Dialogs,
  vcl.ExtCtrls, LabelNola, contnrs, vcl.buttons, vcl.stdctrls;

const
     // Minimum count of the rows above the cable picture. Must be atleast 2.
     CPN_MIN_ROW_COUNT = 2;

     // Defaul count of the rows above the cable picture. Must be atleast 2.
     CPN_DEFAULT_ROW_COUNT = 3;

     // Informs how many pixels the pT-mark is from right border.
     CPN_PT_FROM_RIGHT = 12;
type
  TCablePanelNola = class(TPanel)
  private
    { Private declarations }

    // Labels that are used from displaying string rows above the cable picture
    m_rowLabels: array of TLabelNola;
    m_trueWidth: integer;            // Real width of the panel.
    m_trueHeight: integer;           // Real height of the panel
    m_minimizeButton: TSpeedButton;  // Minimize button    === DEVELOPER1: Vaihtuva kirjakuvake =Supista/Lavenna palsta.
    m_infoButton: TButton;           // Information button === DEVELOPER1: Johto-osapainike [01]...[n] #################
    m_cableImage: TImage;            // Image on the bottom of the panel
    m_lineWidth: Integer;            // Width of the cable line
    m_lineColor: TColor;             // Color of the cable line
    m_lineStyle: TPenStyle;          // Style of the cable line
    m_lineTop: integer;              // Top of the cable line
    m_centreName: TLabelNola;        // The name of the centre
    m_showPt: boolean;               // Is there PT-mark in the end of the cable?
    m_ptLabel: TLabelNola;           // PT-mark
    m_startImage: TImage;            // Image at the beginning of the cable
    m_infoButtonOnLeft: boolean;     // Is the info button on the left corner
    m_data: TObject;                 // An object that is connected to this panel
    m_OnMouseMoveEvent: TMouseMoveEvent; // Procedure that is called on mouse move
    m_OnMouseDownEvent: TMouseEvent; // Procedure that is called when OnMouseDown event occurs

    // Function set the m_RealWidth and m_RealHeight values
    procedure  CalculateDimensions;

    // Function configures the layout
    procedure  SetLayout;

    // Sets the number of the string rows before cable picture.
    // Function is automatically called when the rowCount property is set.
    // rowCount:  new count of the string rows
    procedure   WriteRowCount(rowCount: integer);

    // Returns the number of string rows before cable picture.
    // Function is automatically called when the rowCount property is read.
    // return:  count of the string rows
    function    ReadRowCount: integer;

    // Sets the string to specific row.
    // Function is automatically called when the rows-property is set.
    // rowIndex:  index of the row
    // rowString: string to be set to the row
    procedure   WriteRows(rowIndex: integer; const rowString: string);

    // Returns the string from given row.
    // Function is automatically called when the rows-property is read.
    // rowIndex: index of the row
    // return:   string of the row
    function    ReadRows(rowIndex: integer): string;

    // Function writes new width of the component
    // Function is automatically called when the width-property is set.
    // value:  new width
    procedure WriteWidth(value: integer);

    // Function returns width of the component.
    // Function is automatically called when the width-property is read.
    // return: width of the component
    function  ReadWidth: integer;

    // Function writes new height of the component
    // Function is automatically called when the height-property is set.
    // value:  new height
    procedure WriteHeight(value: integer);

    // Function returns height of the component
    // Function is automatically called when the height-property is read.
    // return: height of the component
    function  ReadHeight: integer;

    // Function sets the new width of the cable line
    // Function is automatically called when the LineWidth-property is set.
    // value:  new width
    procedure WriteLineWidth(value: integer);

    // Function sets the new color of the cable line
    // Function is automatically called when the LineColor-property is set.
    // value:  new color
    procedure WriteLineColor(value: TColor);

    // Function sets the new style of the cable line
    // Function is automatically called when the LineStyle-property is set.
    // value:  new style
    procedure WriteLineStyle(value: TPenStyle);

    // Function sets the new name of the cable centre
    // Function is automatically called when the Name-property is set.
    // value:  new name
    procedure WriteName(const value: string);

    // Function returns name of the cable centre.
    // Function is automatically called when the Name-property is read.
    // return: name of the cable centre
    function  ReadName: string;

    // Function enables/disables the PT-mark in the of the cable
    // Function is automatically called when the ShowPt-property is set.
    // value:  enable/disable PT-mark
    procedure WriteShowPt(value: boolean);

    // Function sets the new starting image for the cable
    // Function is automatically called when the Start-property is set.
    // value:  new start image
    procedure WriteStart(value: TImage);

    // Function sets the info button on left or bottom border.
    // Function is automatically called when the InfoButtonOnLeft-property is set.
    // value:  set the infoButton to left corner or bottom
    procedure WriteInfoButtonOnLeft(value: boolean);

    // Function sets the procedure that is called when mouse moves over the component
    // Function is automatically called when the OnMouseMove-property is set.
    // value:  new event procedure
    procedure WriteOnMouseMove(value: TMouseMoveEvent);

    // Function sets the procedure that is called when mouse is clicked over the component
    // Function is automatically called when the OnClick-property is set.
    // value:  new event procedure
    procedure WriteOnClick(value: TNotifyEvent);

    // Function sets the procedure that is called when mouse is double clicked over the component
    // Function is automatically called when the OnDblClick-property is set.
    // value:  new event procedure
    procedure WriteOnDblClick(value: TNotifyEvent);

    // Function sets the procedure that is called when dragin moves over the component
    // Function is automatically called when the OnDragOver-property is set.
    // value:  new event procedure
    procedure WriteOnDragOver(value: TDragOverEvent);

    // Function reads the procedure that is called when dragin moves over the component
    // Function is automatically called when the OnDragOver-property is read.
    // return:  event procedure
    function ReadOnDragOver(): TDragOverEvent;

    // Function that is called when the drag over happens in any child component
    procedure EventDragOver(Sender, Source: TObject; X, Y: Integer;
                            State: TDragState; var Accept: Boolean);

    // Function sets the procedure that is called when grag stops to the component
    // Function is automatically called when the OnDragDrop-property is set.
    // value:  new event procedure
    procedure WriteOnDragDrop(value: TDragDropEvent);

    // Function reads the procedure that is called when grag stops to the component
    // Function is automatically called when the OnDragDrop-property is read.
    // return:  event procedure
    function ReadOnDragDrop(): TDragDropEvent;

    // Function that is called when the drag drop happens in any child component
    procedure EventDragDrop(Sender, Source: TObject; X, Y: Integer);

    // Function sets the procedure that is called when dragging of the component ends
    // Function is automatically called when the OnEndDrag-property is set.
    // value:  new event procedure
    procedure WriteOnEndDrag(value: TEndDragEvent);

    // Function that is called when the drag end happens to any child components
    procedure EventEndDrag(Sender, Target: TObject; X, Y: Integer);

    // Function sets the drag mode
    // Function is automatically called when the DragMode-property is set.
    // value:  new drag mode
    procedure WriteDragMode(value: TDragMode);

    // Function gets the drag mode
    // Function is automatically called when the DragMode-property is read.
    // return:  current drag mode
    function ReadDragMode(): TDragMode;

    // Function sets the procedure that is called when OnMouseDown event occurs
    // Function is automatically called when the OnMouseDown-property is set.
    // value:  new event procedure
    procedure WriteOnMouseDown(value: TMouseEvent);

    // Function reads the procedure that is called when OnMouseDown event occurs
    // Function is automatically called when the OnMouseDown-property is read.
    // return:  event procedure
    function ReadOnMouseDown: TMouseEvent;

    // Function that is called when the OnMouseDown event happens in any child controls
    procedure EventOnMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);

    // Function that is called when the OnMouseUp event happens in any child controls
    procedure EventOnMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);

  protected
    { Protected declarations }
    procedure Paint; override;

  public
    { Public declarations }

    // Creates a new instance of the object.
    constructor Create(AOwner: TComponent); override;

    // Destroyes the object instance.
    destructor Destroy; override;

    // Strings that are displayed in the rows
    property rows[index: integer]: string read ReadRows write WriteRows;

    // Recalculates the layout and repaints the component
    procedure Repaint; override;

  published
    { Published declarations }

    // Count of the rows above the
    property rowCount: integer read ReadRowCount write WriteRowCount;

    // Real width of the panel.
    property TrueWidth: Integer Read m_trueWidth;

    // Real height of the panel.
    property TrueHeight: Integer Read m_trueHeight;

    // Button for minimizing the cable
    property MinimizeButton: TSpeedButton Read m_minimizeButton;

    // Button for modifying the cable information
    property InfoButton: TButton Read m_infoButton;  

    // Width of the component
    property Width: Integer read ReadWidth write WriteWidth;

    // Height of the component
    property Height: Integer read ReadHeight write WriteHeight;

    // Width of the cable line
    property LineWidth: Integer read m_lineWidth write WriteLineWidth;

    // Color of the cable line
    property LineColor: TColor read m_lineColor write WriteLineColor;

    // Style of the cable line
    property LineStyle: TPenStyle read m_lineStyle write WriteLineStyle;

    // Top of the line
    property LineTop: integer read m_lineTop;

    // Name of the centre
    property Name: string read ReadName write WriteName;

    // Is there PT mark in the end of the cable
    property ShowPt: boolean read m_showPt write WriteShowPt;

    // The image in the beginning of the cable
    property Start: TImage read m_startImage write WriteStart;

    // Defines that info button is in the left corner
    property InfoButtonOnLeft: boolean read m_infoButtonOnLeft write WriteInfoButtonOnLeft;

    // Defines a data object that is bound to this panel
    property Data: TObject read m_data write m_data;

    // Override properties
    property OnMouseMove: TMouseMoveEvent write WriteOnMouseMove;
    property OnClick:     TNotifyEvent    write WriteOnClick;
    property OnDblClick:  TNotifyEvent    write WriteOnDblClick;
    property OnMouseDown: TMouseEvent     read ReadOnMouseDown write WriteOnMOuseDown;
    property OnDragOver:  TDragOverEvent  read ReadOnDragOver write WriteOnDragOver;
    property OnDragDrop:  TDragDropEvent  read ReadOnDragDrop write WriteOnDragDrop;
    property OnEndDrag:   TEndDragEvent   write WriteOnEndDrag;
    property DragMode:    TDragMode       read ReadDragMode   write WriteDragMode;
  end;

procedure Register;

implementation

uses
  vcl.menus;

///////////////////////////////////////////////////////////////////////////////
procedure Register;
begin
  RegisterComponents('Nola', [TCablePanelNola]);
end;

///////////////////////////////////////////////////////////////////////////////
constructor TCablePanelNola.Create(AOwner: TComponent);
begin
  inherited;

  // Set the events
  m_OnMouseMoveEvent := nil;
  m_OnMouseDownEvent := nil;
  inherited OnMouseDown := EventOnMouseDown;
  inherited OnMouseUp := EventOnMouseUp;
  tag := Integer(self);

  // Create the image below
  m_cableImage := TImage.Create(self);
  m_cableImage.parent :=   self;
  m_cableImage.visible :=  true;
  m_cableImage.Autosize := False;
  m_cableImage.Stretch :=  False;
  m_cableImage.tag := Integer(self);
  m_cableImage.name :=  inherited Name;
  m_cableImage.OnMouseDown := EventOnMouseDown;
  m_cableImage.OnMouseUp := EventOnMouseUp;

  // Create miminize button
  m_minimizeButton := TSpeedButton.Create(self);
  m_minimizeButton.parent := self;
  m_minimizeButton.visible := true;
  m_minimizeButton.tag := Integer(self);
  m_minimizeButton.name := inherited Name;
  m_minimizeButton.OnMouseDown := EventOnMouseDown;
  m_minimizeButton.OnMouseUp := EventOnMouseUp;

  // Create the image below
  m_startImage := TImage.Create(self);
  m_startImage.parent :=   self;
  m_startImage.visible :=  true;
  m_startImage.Autosize := False;
  m_startImage.Stretch :=  False;
  m_startImage.tag :=  Integer(self);
  m_startImage.name := inherited Name;
  m_startImage.OnMouseDown := EventOnMouseDown; 
  m_startImage.OnMouseUp := EventOnMouseUp;

  // Create info button
  m_infoButton := TButton.Create(self);
  m_infoButton.parent :=  self;
  m_infoButton.visible := true;
  m_infoButton.left :=   50; //<,,Left,Height,Width  MUUTTAMINEN EI VAIKUTA MIHINKÄÄN, TODETTU 8.0.6
  m_infoButton.height := 30;
  m_infoButton.width :=  m_infoButton.Height;
  m_infoButton.tag := Integer(self);
  m_infoButton.name := inherited Name;
  m_infoButton.OnMouseDown := EventOnMouseDown;
  m_infoButton.OnMouseUp := EventOnMouseUp;

  // Create the centre name label
  m_centreName := TLabelNola.Create(self);
  m_centreName.Parent := self;
  m_centreName.visible := true;
  m_centreName.font.Style := [];                     //<-120.5i:  oli [fsBold], turvotti liikaa, FormatCable.PAS/PRC FormatCablePanel´in <b> paljon parempi.
  m_centreName.tag := Integer(self);
  m_centreName.name := inherited Name;
  m_centreName.OnMouseDown := EventOnMouseDown;
  m_centreName.OnMouseUp := EventOnMouseUp;

  // Create the pt label
  m_ptLabel := TLabelNola.Create(self);
  m_ptLabel.Parent := self;
  m_ptLabel.visible := true;
  m_ptLabel.tag := Integer(self);
  m_ptLabel.name := inherited Name;
  m_ptLabel.OnMouseDown := EventOnMouseDown;
  m_ptLabel.OnMouseUp := EventOnMouseUp;

  // Set the default settings
  rowCount := CPN_DEFAULT_ROW_COUNT;
  color := clWhite;
//color := clYellow; //§§§c§§§ ei muutu 806. Muuttuu Johto.PAS´sissa, ks. TJohto.Create,
  BorderStyle := bsNone;
  BevelInner :=  bvNone;
  BevelOuter :=  bvNone;
  BorderWidth := 0;
  rows[0] := '';
  rows[1] := '';
  rows[2] := '';
  LineWidth := 1;
  LineColor := clBlack;
//LineColor := clLime; //§§§c§§§ ei muutu 806.
  LineStyle := psSolid;
  name := '';
  caption := '';
  infoButtonOnLeft := false; //<DEVELOPER1:  FA =Ei tule ylös vasemmalle HideBtn´in yläp. vaan johdon päälle ~ keskelle,
  m_ptLabel.caption := 'PT';
end;//Create

///////////////////////////////////////////////////////////////////////////////
destructor TCablePanelNola.Destroy;
begin
     inherited;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.Repaint;
begin
     SetLayout;
     inherited;
end;

///////////////////////////////////////////////////////////////////////////////
procedure  TCablePanelNola.CalculateDimensions;
var
   controlIndex, lowest, currentBottom: integer;
   biggestLeft, currentLeft: integer;
   control: TControl;
begin
     // Go through the controls and calculate the biggest left
     biggestLeft := 0;
     for controlIndex := 0 to ControlCount - 1 do
     begin
        control := controls[controlIndex];

        if control is TImage then
          // Skip the image because it has always the same size
          currentLeft := 0
        else if control is TLabelNola then
          currentLeft := control.Left + TLabelNola(control).trueWidth
        else
          currentLeft := control.Left + control.Width;

        if (currentLeft > biggestLeft) then
          biggestLeft := currentLeft;
     end;

     m_trueWidth := biggestLeft;

     // Go through the controls and calculate the lowest bottom
     lowest := 0;
     for controlIndex := 0 to ControlCount - 1 do
     begin
        control := controls[controlIndex];

        if control is TImage then
          // Skip the image because it has always the same size
          currentBottom := 0
        else if control is TLabelNola then
          currentBottom := control.Top + TLabelNola(control).trueHeight
        else
          currentBottom := control.Top + control.Height;

        if (currentBottom > lowest) then
          lowest := currentBottom;
     end;

     m_trueHeight := lowest;
end;

///////////////////////////////////////////////////////////////////////////////
procedure  TCablePanelNola.SetLayout;
const
  SPACE_BETWEEN_BUTTON_AND_LABEL = 2;
var
   maxHeight, rowIndex, previousBottom, previousLeft, newLeft: integer;
   lineFromBottom, nameFromBottom, bottom, pictureFromBottom: integer;
   indentBottom{,Yar{+8.0.6}: integer;
begin
     // All rows should have the same height so find the maximum value
     maxHeight := 0;
     previousLeft := 0;
     indentBottom := 0;
     for rowIndex := 0 to rowCount - 1 do
     begin
          if m_rowLabels[rowIndex].trueHeight > maxHeight then
             maxHeight := m_rowLabels[rowIndex].trueHeight;
     end;

     // Set the button
     if (m_infoButtonOnLeft = false) then //TR = InfoButton is in left corner,  FA = bottom, komm. +8.0.6
     begin                                 
          m_infoButton.Left := 50; //<DEVELOPER1:  Poistettaessa liittymiä, sen tilalle siirtyvän Edka[]:n JohtoBtn [1]
                 // jäisi sulakkeen päälle, TODETTU.  InfoButtonOnLeft := FA  PRC TJohto.WriteEdvJohto´ssa. +8.0.0
          m_infoButton.Top := 0;   //<================================== DEVELOPER1: LiittymäBtn (01 tms.)

          m_minimizeButton.Top :=  m_infoButton.Top + m_infoButton.Height;
          m_minimizeButton.Left := 0;

          // Minimize button is acknowledged only if is visible
          if (m_minimizeButton.Visible) then
          begin
             previousLeft := m_minimizeButton.width + SPACE_BETWEEN_BUTTON_AND_LABEL;
             indentBottom := m_minimizeButton.Top + m_minimizeButton.height;
          end;
     end
     else
     begin
          // Center the button according to hide button.  ============== DEVELOPER1: LiittymäBtn (01 tms.)
          m_infoButton.Top := 0;
        //m_infoButton.Left := ((m_minimizeButton.width - m_infoButton.width) div 2) +1; //< +1  =RePuKOE
                                               //'Ei kestä Left +1; minimizeBtn häipyy osin näkymättömiin.
          m_infoButton.Left := (m_minimizeButton.width - m_infoButton.width) div 2;

          // Info button is acknowledged only if it is visible
          newLeft := m_infoButton.left + m_infoButton.width + SPACE_BETWEEN_BUTTON_AND_LABEL;
          if (m_infoButton.Visible) and (newLeft > previousLeft) then
          begin
             previousLeft := newLeft;
             indentBottom := m_infoButton.Top + m_infoButton.height;
          end;

          m_minimizeButton.Top :=  m_infoButton.Top + m_infoButton.Height;
          m_minimizeButton.Left := 0;

          // Minimize button is acknowledged only if it is visible
          newLeft := m_minimizeButton.left + m_minimizeButton.width + SPACE_BETWEEN_BUTTON_AND_LABEL;
          if (m_minimizeButton.Visible) and (newLeft > previousLeft) then
          begin
             previousLeft := newLeft;
             indentBottom := m_minimizeButton.Top + m_minimizeButton.height;
          end;

     end;
     previousBottom := 0;
     if (indentBottom<99) and (indentBottom>0)  then ;  //<Ettei herja:  Value assined to "indentBottom" never ...

     // Go through the rows and locate them
     for rowIndex := 0 to rowCount - 1 do
     begin
          m_rowLabels[rowIndex].top := previousBottom;

          // Check if the row has to be intended or not
        //if (indentBottom > m_rowLabels[rowIndex].top) then                                    //< -8.0.6
          if rowIndex<4  then                                                                   //< +8.0.6
             m_rowLabels[rowIndex].left := previousLeft // Indent
          else
             m_rowLabels[rowIndex].left := 0;           // Below buttons -> no indent

          m_rowLabels[1].Height := maxHeight;           //<806: Vainko [1] asetetaan ???
          previousBottom := m_rowLabels[rowIndex].top + m_rowLabels[rowIndex].height;
        //previousBottom := (rowIndex+1) *maxHeight;    //<806
        //m_rowLabels[rowIndex].left := 25;             //Koe: 30 hivenen leveä, workkii OK. 806
     end;

     // Add centre name
     m_centreName.width := m_centreName.trueWidth;
     m_centreName.height := m_centreName.trueHeight;

     // Check if the centre name fits after the info button
     if (m_infoButtonOnLeft = false) then
     begin
       if (width - m_infoButton.left -  m_infoButton.Width > m_centreName.width) then
            // Centre name fits after info button
            m_centreName.left := width - m_centreName.width
       else
           // Centre name did not fit so start from info button
           m_centreName.left := m_infoButton.Left + m_infoButton.Width;
     end
     else
     begin
        // Centre name fits after info button
        m_centreName.left := width - m_centreName.width
     end;

     // Centre name is above the line
     bottom := height;
     lineFromBottom := Trunc(m_LineWidth/2) + 1 + m_ptLabel.trueHeight;

     // The width of the line has to be notified.
     nameFromBottom := m_CentreName.trueHeight + lineFromBottom + Trunc(LineWidth / 2);

     // Check if the info button is bigger than name
     pictureFromBottom := nameFromBottom;
     if (m_infoButtonOnLeft = false) then
     begin
       if (pictureFromBottom < m_infoButton.height) then
          pictureFromBottom := m_infoButton.height;
     end;

     // Check if the name and line fits to the panel
     if (previousBottom > bottom - pictureFromBottom) then
     begin
        // They did not fit to the panel so move them lower
        bottom := previousBottom + pictureFromBottom;
     end;

     m_centreName.top := bottom - nameFromBottom; //<DEVELOPER1: JK:n nimi

     if (m_infoButtonOnLeft = false) then
     begin
          m_infoButton.top := bottom - lineFromBottom - Trunc(m_infoButton.Height / 2);  // Info button is on bottom
     end;
     // Add the cable image to behind of the info button;
     m_cableImage.Width :=  1000;  // Image can not change the size dynamically
     m_cableImage.Height := 100;
     m_cableImage.top :=    bottom - m_cableImage.height; //<DEVELOPER1: Vaakakaapeliviiva
     m_cableImage.Left :=   0;

     // Draw new cable image
     // Clear the image
     m_cableImage.Canvas.Brush.Color := color;
     m_cableImage.Canvas.FillRect(Rect(0,0,m_cableImage.Width,m_cableImage.Height));

     // Draw line
     m_cableImage.Canvas.Pen.Color := m_lineColor;
     m_cableImage.Canvas.Pen.Width := m_LineWidth;
     m_cableImage.Canvas.Pen.Style := m_lineStyle;
     m_cableImage.Canvas.MoveTo(0, m_cableImage.height - lineFromBottom);
     m_cableImage.Canvas.LineTo(width, m_cableImage.height -lineFromBottom);
     m_lineTop := bottom - lineFromBottom; //<DEVELOPER1: JK-symbolin yr.

     // Draw PT-mark if needed
     if (m_showPt) then
     begin
          m_ptLabel.visible := true;
          m_ptlabel.Invalidate;
          // Line from end point to the PT-mark
          m_cableImage.Canvas.LineTo(width - CPN_PT_FROM_RIGHT, m_cableImage.height -lineFromBottom + Trunc(m_ptLabel.trueHeight/2) + 4);
          // Box beside PT-mark
          m_cableImage.Canvas.Brush.Color := m_lineColor;
          m_cableImage.Canvas.FillRect(Rect(width - CPN_PT_FROM_RIGHT    , m_cableImage.height -lineFromBottom + 3,
                                            width - CPN_PT_FROM_RIGHT + 3, m_cableImage.height -lineFromBottom + m_ptLabel.trueHeight));
     end
     else
         m_ptLabel.visible := false;

     m_ptLabel.Left := width - m_ptLabel.trueWidth - CPN_PT_FROM_RIGHT;
     m_ptLabel.top :=  bottom - lineFromBottom + Trunc(m_LineWidth/2) + 1;

     // Set the start image
     m_startImage.Top := bottom - lineFromBottom - Trunc(m_startImage.height / 2); //<DEVELOPER1: Vaakasulakkeen korko

     CalculateDimensions;
end;//SetLayout

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.Paint;
begin
     Inherited;
end;

///////////////////////////////////////////////////////////////////////////////
procedure   TCablePanelNola.WriteRowCount(rowCount: integer);
var
   tmp: array of TLabelNola;
   rowIndex, oldCount: integer;
   rowLabel: TLabelNola;
begin
     // Count of the rows can not less than minimum
     if rowCount < CPN_MIN_ROW_COUNT then
        rowCount := CPN_MIN_ROW_COUNT;

     // Change the labels only if the count of the rows changes
     if rowCount <> Length(m_rowLabels) then
     begin
          oldCount := Length(m_rowLabels);

          // Copy old labels to temporary array
          SetLength(tmp, oldCount);
          for rowIndex := 0 to oldCount - 1 do
          begin
               tmp[rowIndex] := m_rowLabels[rowIndex];
          end;

          // Set the new size for labels
          SetLength(m_rowLabels, rowCount);

          // Check if old labels has to be deleted or new has to be created
          if (rowCount > oldCount) then
          begin
               // Copy old labels from the tmp
               for rowIndex := 0 to oldCount - 1 do
                   m_rowLabels[rowIndex] := tmp[rowIndex];

               // New labels has to be created
               for rowIndex := rowCount - 1 downto oldCount do
               begin
                    rowLabel := TLabelNola.Create(self); // CablePanelNola frees the labels
                    rowLabel.visible := true;
                    rowLabel.color :=   clWhite;
                  //rowLabel.color :=   clYellow; //§§c§§ ei muutu
                    rowLabel.parent :=  self;       // Add label to this panel
                    rowLabel.tag :=     Integer(self);
                    m_rowLabels[rowIndex] := rowLabel;
                    rowLabel.OnMouseDown :=  EventOnMouseDown;
                    rowLabel.OnMouseUp :=    EventOnMouseUp;
               end;
          end
          else
          begin
               // Copy old labels from the tmp
               for rowIndex := 0 to rowCount - 1 do
                   m_rowLabels[rowIndex] := tmp[rowIndex];

               // Old has to be deleted
               for  rowIndex := oldCount-1 downto rowCount do
               begin
                    // Delete label that is not needed anymore
                    rowLabel := tmp[rowIndex];
                    rowLabel.parent := nil; // Remove label from this panel
                    rowLabel.Free;
               end;
          end;

          SetLayout;  // Refresh the layout
     end; 
end;

///////////////////////////////////////////////////////////////////////////////
function    TCablePanelNola.ReadRowCount: integer;
begin
     result := Length(m_rowLabels);
end;

///////////////////////////////////////////////////////////////////////////////
procedure   TCablePanelNola.WriteRows(rowIndex: integer; const rowString: string);
begin
     if (rowIndex >= 0) and (rowIndex < rowCount) then
     begin
          // Set the new value for the row
          if (m_rowLabels[rowIndex].caption <> rowString) then
          begin
            m_rowLabels[rowIndex].caption := rowString;
            SetLayout;  // Refresh the layout
          end;
     end;
end;

///////////////////////////////////////////////////////////////////////////////
function    TCablePanelNola.ReadRows(rowIndex: integer): string;
begin
  result := '';
  if (rowIndex >= 0) and (rowIndex < rowCount) then
    result := m_rowLabels[rowIndex].caption;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.WriteWidth(value: integer);
begin
  if (width <> value) then
  begin
    inherited Width := value;
    SetLayout;
  end;
end;

///////////////////////////////////////////////////////////////////////////////
function  TCablePanelNola.ReadWidth: integer;
begin
  result := inherited Width;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.WriteHeight(value: integer);
begin
  if (Height <> value) then
  begin
    inherited Height := value;
    SetLayout;
  end;
end;

///////////////////////////////////////////////////////////////////////////////
function  TCablePanelNola.ReadHeight: integer;
begin
  result := inherited Height;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.WriteLineWidth(value: integer);
begin
  m_lineWidth := value;
  SetLayout;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.WriteLineColor(value: TColor);
begin
  m_lineColor := value;
  SetLayout;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.WriteLineStyle(value: TPenStyle);
begin
  m_lineStyle := value;
  SetLayout;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.WriteName(const value: string);
begin
  if (m_centreName.caption <> value) then
  begin
    m_centreName.caption := value;
    SetLayout;
  end;
end;

///////////////////////////////////////////////////////////////////////////////
function  TCablePanelNola.ReadName: string;
begin
     result := m_centreName.caption; 
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.WriteShowPt(value: boolean);
begin
  if (m_showPt <> value) then
  begin
    m_showPt := value;
    SetLayout;
  end;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.WriteStart(value: TImage);
var
   tmp: TImage;
begin
     // Create new image because the size of the old image can not be changed
     m_startImage.parent := nil;
     tmp := TImage.Create(self);          //<Siellä antaa arvotwidtth=102 ja Height=105
     tmp.parent := self;
     if value<>NIL  then begin            //<+12.0.04 ehto lisätty. KOE KOE
        tmp.width := value.width;
        tmp.height := value.height;  end;
     tmp.Transparent := m_startImage.Transparent;
     tmp.tag := m_startImage.tag;
     tmp.name := m_startImage.name;
     tmp.OnMouseDown := m_startImage.OnMouseDown;
     tmp.OnMouseUp := m_startImage.OnMouseUp;
     tmp.DragMode := m_startImage.DragMode;
     m_startImage.Free;
     m_startImage := tmp;

     m_startImage.Canvas.CopyMode := cmSrcCopy;
     if value<>NIL  then begin            //<+12.0.04 ehto lisätty. KOE KOE
        m_startImage.canvas.CopyRect(Rect(0,0, value.width, value.height),
                                     value.canvas,
                                     Rect(0,0, value.width, value.height));  end;
     SetLayout;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.WriteInfoButtonOnLeft(value: boolean);
begin
     m_infoButtonOnLeft := value;
     SetLayout;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.WriteOnMouseMove(value: TMouseMoveEvent);
var
   rowIndex: integer;
begin
     inherited OnMouseMove := value;

     // Set the event to all components
     for rowIndex := 0 to rowCount - 1 do
         m_rowLabels[rowIndex].OnMouseMove := value;
     m_cableImage.OnMouseMove := value;
     m_centreName.OnMouseMove := value;
     m_ptLabel.OnMouseMove := value;
     m_startImage.OnMouseMove := value;
     m_minimizeButton.OnMouseMove := value;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.WriteOnClick(value: TNotifyEvent);
var
   rowIndex: integer;
begin
     inherited OnClick := value;

     // Set the event to all components
     for rowIndex := 0 to rowCount - 1 do
         m_rowLabels[rowIndex].OnClick := value;
     m_cableImage.OnClick := value;
     m_centreName.OnClick := value;
     m_ptLabel.OnClick := value;
     m_startImage.OnClick := value;
   //m_minimizeButton.OnClick := value;  <DEVELOPER2 -8.0.6
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.WriteOnDblClick(value: TNotifyEvent);
var
   rowIndex: integer;
begin
     inherited OnDblClick := value;

     // Set the event to all components
     for rowIndex := 0 to rowCount - 1 do
         m_rowLabels[rowIndex].OnDblClick := value;
     m_cableImage.OnDblClick := value;
     m_centreName.OnDblClick := value;
     m_ptLabel.OnDblClick := value;
     m_startImage.OnDblClick := value;
   //m_minimizeButton.OnDblClick := value;  <DEVELOPER2 -8.0.6
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.WriteOnDragOver(value: TDragOverEvent);
var
   rowIndex: integer;
begin
     inherited OnDragOver := value;

     // Set the event to all components
     for rowIndex := 0 to rowCount - 1 do
         m_rowLabels[rowIndex].OnDragOver := EventDragOver;
     m_cableImage.OnDragOver := EventDragOver;
     m_centreName.OnDragOver := EventDragOver;
     m_ptLabel.OnDragOver := EventDragOver;
     m_startImage.OnDragOver := EventDragOver;
     m_infoButton.OnDragOver := EventDragOver;
end;

///////////////////////////////////////////////////////////////////////////////
function TCablePanelNola.ReadOnDragOver(): TDragOverEvent;
begin
     result := inherited OnDragOver;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.EventDragOver(Sender, Source: TObject; X, Y: Integer;
          State: TDragState; var Accept: Boolean);
var
   event: TDragOverEvent;
begin
     event := inherited OnDragOver;

     // Change the event only if the sender is a child control
     if (Sender is TControl) and (TControl(Sender).parent = self) then
     begin
          event(self, source, x, y, state, accept);
     end
     else
     begin
          event(Sender, source, x, y, state, accept);
     end;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.WriteOnDragDrop(value: TDragDropEvent);
var
   rowIndex: integer;
begin
     inherited OnDragDrop := value;

     // Set the event to all components
     for rowIndex := 0 to rowCount - 1 do
         m_rowLabels[rowIndex].OnDragDrop := EventDragDrop;
     m_cableImage.OnDragDrop := EventDragDrop;
     m_centreName.OnDragDrop := EventDragDrop;
     m_ptLabel.OnDragDrop := EventDragDrop;
     m_startImage.OnDragDrop := EventDragDrop;
     m_infoButton.OnDragDrop := EventDragDrop;
end;

///////////////////////////////////////////////////////////////////////////////
function TCablePanelNola.ReadOnDragDrop(): TDragDropEvent;
begin
     result := inherited OnDragDrop;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.EventDragDrop(Sender, Source: TObject; X, Y: Integer);
var
   event: TDragDropEvent;
begin
     event := inherited OnDragDrop;
     event(self, source, x, y);
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.WriteOnEndDrag(value: TEndDragEvent);
var
   rowIndex: integer;
begin
     inherited OnEndDrag := value;

     // Set the event to all components
     for rowIndex := 0 to rowCount - 1 do
         m_rowLabels[rowIndex].OnEndDrag := EventEndDrag;
     m_cableImage.OnEndDrag := EventEndDrag;
     m_centreName.OnEndDrag := EventEndDrag;
     m_ptLabel.OnEndDrag := EventEndDrag;
     m_startImage.OnEndDrag := EventEndDrag;
     m_infoButton.OnEndDrag := EventEndDrag;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.EventEndDrag(Sender, Target: TObject; X, Y: Integer);
var
   event: TEndDragEvent;
begin
     event := inherited OnEndDrag;

     // Change the event only if the sender is a child control
     if (Sender is TControl) and (TControl(Sender).parent = self) then
     begin
          event(self, Target, x, y);
     end
     else
     begin
          event(Sender, Target, x, y);
     end;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.WriteDragMode(value: TDragMode);
begin
  inherited DragMode := value;

  // Automatic drag mode is implemented manually because otherwise source of the
  // drag would be child controls instead of the CablePanelNola.
end;

///////////////////////////////////////////////////////////////////////////////
function TCablePanelNola.ReadDragMode(): TDragMode;
begin
  result := inherited DragMode;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.WriteOnMouseDown(value: TMouseEvent);
begin
  m_OnMouseDownEvent := value;
end;

///////////////////////////////////////////////////////////////////////////////
function TCablePanelNola.ReadOnMouseDown: TMouseEvent;
begin
  result := m_OnMouseDownEvent;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.EventOnMouseDown(Sender: TObject; Button: TMouseButton;
                                           Shift: TShiftState; X, Y: Integer);
begin
  // Check if the dragging should be started
  if (DragMode = dmAutomatic) and
     (Button = mbLeft) and not (Sender is TButton) then
  begin
    BeginDrag(true, -1);
  end;

  if (Assigned(m_OnMouseDownEvent)) then
  begin
     // Change the event only if the sender is a child control
     if (Sender is TControl) and (TControl(Sender).parent = self) then
     begin
          m_OnMouseDownEvent(sender, Button, shift, x, y);
     end
     else
     begin
          m_OnMouseDownEvent(sender, Button, shift, x, y);
     end;
  end;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TCablePanelNola.EventOnMouseUp(Sender: TObject; Button: TMouseButton;
                                         Shift: TShiftState; X, Y: Integer);
begin
end;

end.
