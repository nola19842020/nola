{
* Copyright (c) 2020, Reijo Pursiainen, Hannu Pursiainen
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of Reijo Pursiainen, Hannu Pursiainen nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY REIJO PURSIAINEN, HANNU PURSIAINEN AND
* CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
* BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL REIJO PURSIAINEN,
* HANNU PURSIAINEN AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
}

///////////////////////////////////////////////////////////////////////////////
//
// FileName:  ComboBoxXY.pas
// Location:  src\components
// Abstract:  Label, jota voidaan ohjata tekstim‰‰reill‰ (ks. NolaComp.pas).
//            Mik‰li Align-property on muu kuin "alNone", AutoSize-propertyn tulee olla "false". =4.0.0/KAI
//
///////////////////////////////////////////////////////////////////////////////
//
// Following fields are automatically generated by the version control system:
//
// $Revision: 1.3 $
//     $Date: 2005/10/09 13:58:05 $
//
///////////////////////////////////////////////////////////////////////////////
//
// Change Log. Old log entries can be removed by deleting them.
// $Log: LabelNola.pas,v $
// Revision 1.3  2005/10/09 13:58:05  DEVELOPER2
// Reijolta 26.9.2005
//
// 
// 10    1.08.02 19:32 DEVELOPER2
// Refresh optimized
// 
// 9     31.07.02 9:42 DEVELOPER2
// - New file header.
// - string parameters to consts

unit LabelNola;

interface

uses
  Windows, Messages, SysUtils, Classes, Vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs,
  Vcl.StdCtrls, NolaComp, Vcl.mask, ComboBoxXY;

type
  TLabelNola = class(TLabel)
  private
    { Private declarations }
    defaultFont:     TFont;
    results:         TParseResults;
    metafile:        TMetaFile;
    m_realWidth:       integer;
    m_realHeight:      integer;
    m_trueWidth:       integer;
    m_trueHeight:      integer;
    textPixelWidth:  integer;
    textPixelHeight: integer;
    firstTime:       Boolean;
    FCaption:        string;

    FdesignScreenHeight: integer;
    FdesignScreenWidth: integer;

    procedure SetDesignInformation;
    procedure WriteLeft(value: integer);
    procedure WriteTop(value: integer);
    procedure WriteWidth(value: integer);
    procedure WriteHeight(value: integer);
    procedure WriteDesignScreenWidth(value: integer);
    procedure WriteDesignScreenHeight(value: integer);
    procedure WriteAutosize(value: boolean);
    function  ReadLeft: integer;
    function  ReadTop: integer;
    function  ReadWidth: integer;
    function  ReadHeight: integer;
    function  ReadAutosize: boolean;

    procedure WriteCaption(const text: string);
    procedure UpdateMetafile;
    procedure DrawMetafile;

  protected
    { Protected declarations }
    procedure Paint; override;

  public
    { Public declarations }
    constructor Create(Owner: TComponent); override;
    destructor  Destroy; override;
    procedure   Assign(Source: TPersistent); override;
    procedure   PaintTo(canvas: TCanvas; left, top: integer);

  published
    { Published declarations }
    property Caption: string read FCaption write WriteCaption;
    property Left: Integer read ReadLeft write WriteLeft;
    property Top: Integer read ReadTop write WriteTop;
    property Width: Integer read ReadWidth write WriteWidth;
    property Height: Integer read ReadHeight write WriteHeight;
    property AutoSize: Boolean read ReadAutosize write WriteAutosize;
    property DesignScreenHeight: Integer Read FdesignScreenHeight Write WriteDesignScreenHeight;
    property DesignScreenWidth:  Integer Read FdesignScreenWidth  Write WriteDesignScreenWidth;
    property TrueWidth: Integer Read m_trueWidth;
    property TrueHeight: Integer Read m_trueHeight;

  end;

procedure Register;

implementation
                                                
const
     BORDER = 2;

procedure Register;
begin
  RegisterComponents('Nola', [TLabelNola]);
end;

constructor TLabelNola.Create(Owner: TComponent);
begin
     inherited;

     metaFile :=    TMetaFile.Create;
     defaultFont := TFont.Create;
     results :=     TParseResults.Create;
     results.Clear;

     m_realHeight := Height;
     m_realWidth  := Width;

     firstTime := True;
end;

destructor TLabelNola.Destroy;
begin
     results.Destroy;
     defaultFont.Destroy;
     metafile.Destroy;
     inherited;
end;

procedure TLabelNola.WriteCaption(const text: string);
begin
     if (FCaption <> text) then
     begin
          FCaption := text;
          UpdateMetaFile;
     end;

     if (autosize = true) and (Align = alNone) then
     begin
          width := m_realWidth;
          height := m_realHeight;
     end
     else
     begin
          m_realWidth :=  width;
          m_realHeight := height;
     end;

end;

procedure TLabelNola.Paint;
begin
     inherited;
     if (autosize = true) and (Align = alNone) then
     begin
          width := m_realWidth;
          height := m_realHeight;
     end
     else
     begin
          m_realWidth :=  width;
          m_realHeight := height;
     end;

     if (firstTime = True) then
        UpdateMetaFile;

     if (Visible) then
     begin
        DrawMetaFile;
     end;

     firstTime := False;
end;

procedure TLabelNola.DrawMetaFile;
var
   drawRect: TRect;
   positionLeft: integer;
begin
     // Justify the text
     positionLeft := 0;
     case Alignment of
     taLeftJustify:  positionLeft := 0;
     taCenter:       positionLeft := (width - textPixelWidth) div 2;
     taRightJustify: positionLeft := (width - textPixelWidth);
     end;

     // Clear the area
     drawRect.Top :=    0;
     drawRect.Left :=   0;
     drawRect.Right:=   drawRect.Left + width;
     drawRect.Bottom := drawRect.Top + height;
     canvas.brush.Color := Color;

     canvas.FillRect(drawRect);
     // Draw the cache to the screen
     canvas.Draw(positionLeft, 0, metafile);
end;


procedure TLabelNola.UpdateMetafile;
var
   Text: string;
   temp: string;
   i, ti, tag: integer;
   x, xposition: integer;
   y: integer;
   myheight: integer;
   mywidth: integer;
   currLen: integer;
   highest: integer;
   fromLeft, fromRight: integer;
   dest: TRect;
   limit: TRect;
   overLimit: TRect;
   tmpCanvas: TMetaFileCanvas;
   tmpResults:      TParseResults;
   stop: boolean;
   len: integer;

   currResult, tmpResult: TParseResult;
begin
   defaultFont.Assign(font);

   FromLeft  := 0;
   FromRight := 0;

   Text := fcaption;

   Metafile.Clear;

   currResult := TParseResult.Create;
   tmpResult  := TParseResult.Create;
   tmpResults := TParseResults.Create;

   tmpCanvas := TMetaFileCanvas.Create(Metafile, 0);

   currResult.Assign(defaultFont);
   results.Clear;
   tmpCanvas.Font.Assign(defaultFont);
   tmpCanvas.Brush.Color := Color;

   xposition := 0;
   x         := 0;
   y         := 0;
   highest   := 0;

   overLimit.Top    :=  MAX_OVERLIMIT; // (ARect.Bottom - ARect.Top);
   overLimit.Bottom := -MAX_OVERLIMIT; // -(ARect.Bottom - ARect.Top);
   overLimit.Left   :=  MAX_OVERLIMIT; // (ARect.Right - ARect.Left);
   overLimit.Right  := -MAX_OVERLIMIT; // -(ARect.Right - ARect.Left);

   Limit.Top    := 0;
   Limit.Left   := 0;
   Limit.Right  := width;
   Limit.Bottom := height;

   if (autosize = true) and (Align = alNone) then
   begin
        Limit.Right  := m_realWidth;
        Limit.Bottom := m_realHeight;
   end;

   tmpCanvas.FillRect(Limit);

   highest := 0;
   i := 0;

   currResult.halign  := alleft;
   currResult.valign := alBelow;
   tmpResult.Assign(currResult);

   PixelLength(tmpCanvas, tmpResult, results, Text, i , highest);

   results.clear;

   i := 1;
   currLen:= -1;

   stop := false;
   len := length(text);
   if (i > len) then stop := TRUE;

   while(stop = FALSE) do
   begin
        // ti2 := length(Text);
        ti := i;

        // temp2 := Copy(text, i, ti2 - i - 1);
        temp  := ParseText(Text, i, currResult, results, tag);
        // temp3 := Copy(text, i, ti2 - i - 1);

       { Check if there is a change in alignment }
       { if (GetTagLen(temp2, LEFT_TAG) <> 0) OR
           (GetTagLen(temp2, RIGHT_TAG) <> 0) OR
           (GetTagLen(temp2, CENTER_TAG) <> 0) OR
           (currLen = -1) then
        begin
             ti := 0;
             xposition := 0;
             currLen   := PixelLength(tmpCanvas, currResult, results, temp3, ti , highest);
        end
        else
        if (GetTagLen(temp2, ABOVE_TAG) <> 0) OR
           (GetTagLen(temp2, MIDDLE_TAG) <> 0) OR
           (GetTagLen(temp2, BELOW_TAG) <> 0) OR
           (currLen = -1) then
        begin
             ti := 0;
             highest  := 0;
             currLen   := PixelLength(tmpCanvas, currResult, Results, temp3, ti , highest);
        end;      }

        if (tag = LEFT_TAG) OR
           (tag = RIGHT_TAG) OR
           (tag = CENTER_TAG) OR
           (currLen = -1) then
        begin
             ti := 0;
             xposition := 0;
             currLen   := PixelLength(tmpCanvas, currResult, results, text, ti , highest);
        end
        else
        if (tag = ABOVE_TAG) OR
           (tag = MIDDLE_TAG) OR
           (tag = BELOW_TAG) OR
           (currLen = -1) then
        begin
             ti := 0;
             highest  := 0;
             currLen   := PixelLength(tmpCanvas, currResult, tmpResults, text, ti , highest);
        end;

        if (temp <> '') then
        begin
             currResult.AssignTo(tmpCanvas.Font);

             // In some reason TextWidth returns too small width. 2 is
             // tested to be good adjustment in this case
             mywidth  := tmpCanvas.TextWidth(temp) + 2;
             myheight := tmpCanvas.TextHeight(temp);

             case (currResult.valign) of
                  alBelow:  y := Limit.Bottom - myheight ;
                  alMiddle: y := ({Limit.Bottom - myheight - }(Limit.Bottom - Limit.Top - highest)) div 2  - 1;
                  alAbove:  y := Limit.Top    + highest - myheight;
             end;

             case (currResult.halign) of
                  alLeft:
                         begin
                              x := Limit.Left  + xposition ;

                              if (x > Limit.Right - fromRight) then
                              begin
                                 currLen := currLen + (x - Limit.Left - fromLeft);
                                 x := (Limit.Right - fromRight) + xposition;
                              end;
                         end;
                  alCenter: x := Limit.Left  + xposition + (Limit.Right - Limit.Left - currLen) div 2 + 1;
                  alRight:
                         begin
                              x := Limit.Right - currLen + xposition;

                              if (x <= Limit.Left + fromLeft) then
                              begin
                                 currLen := currLen - ( Limit.Left + fromLeft - x);
                                 x := (Limit.Left + fromLeft) + xposition;
                              end;
                         end;
             end;


             { Make clipping rectangle }
             dest.Top    := y;
             dest.Bottom := y + myheight;
             dest.Left   := x;
             dest.Right  := x + mywidth;

             { Check that chracter wont be to big }
             CheckLimits(Limit, dest, overLimit);

             tmpCanvas.TextRect(dest, x, y , temp);

             xposition := xposition + mywidth;

             case currResult.halign of
                  alRight: if fromRight + width > fromRight then
                                        fromRight := fromRight + mywidth;
                  alLeft:  if fromLeft + width > fromLeft then
                                        fromLeft  := fromLeft  + mywidth;
                  alCenter:
             end;
        end;

        if (i > len) then
           stop := TRUE;
   end;

   results.clear;
   tmpCanvas.Destroy;

   textPixelWidth :=  m_realWidth + (overLimit.Right - overLimit.Left);
   textPixelHeight := m_realHeight + (overLimit.Bottom - overLimit.Top);

   if (textPixelWidth < 0) then textPixelWidth := 0;
   if (textPixelHeight < 0) then textPixelHeight := 0;

   if (AutoSize = True) and (Align = alNone) then
   begin
        if (text = '') then
        begin
             m_realWidth  := 0;
             m_realHeight := 0;
        end
        else
        begin
             m_realWidth  := textPixelWidth;
             m_realHeight := textPixelHeight;

             if ((overLimit.Right - overLimit.Left <> 0) and
                 ((overLimit.Right <> -MAX_OVERLIMIT) and
                  (overLimit.Left  <> MAX_OVERLIMIT))) or
                ((overLimit.Bottom - overLimit.Top <> 0) and
                 ((overLimit.Bottom <> -MAX_OVERLIMIT) and
                  (overLimit.Top    <> MAX_OVERLIMIT))) then
               UpdateMetaFile;

        end;
   end
   else
   begin
        m_realWidth  := width;
        m_realHeight := height;
   end;

   m_trueWidth  := textPixelWidth;
   m_trueHeight := textPixelHeight;

   currResult.Free;
   tmpResult.Free;
   tmpResults.Free;

      if (visible) then
         DrawMetaFile;
end;

procedure TLabelNola.Assign(Source: TPersistent);
var
  tmp: TLabel;
  tmpEdit: Tedit;
  tmpCombo: TComboBox;
begin
  if (Source is TLabelNola)  or (Source is TLabel) then
  begin
       tmp := TLabel(source);
       Alignment    := tmp.Alignment;
       AutoSize     := tmp.AutoSize;
       Layout       := tmp.Layout;
       ShowAccelChar:= tmp.ShowAccelChar;
       Transparent  := tmp.Transparent;
       WordWrap     := tmp.WordWrap;
       Align        := tmp.Align;
       Color        := tmp.Color;
       ControlState := tmp.ControlState;
       ControlStyle := tmp.ControlStyle;
       Cursor       := tmp.Cursor;
       DragCursor   := tmp.DragCursor;
       DragMode     := tmp.DragMode;
       Enabled      := tmp.Enabled;
       Font         := tmp.Font;
       Height       := tmp.Height;
       Hint         := tmp.Hint;
       Left         := tmp.Left;
       ParentColor  := tmp.ParentColor;
       ParentFont   := tmp.ParentFont;
       ParentShowHint:= tmp.ParentShowHint;
       PopupMenu    := tmp.PopupMenu;
       ShowHint     := tmp.ShowHint;
       Top          := tmp.Top;
       Width        := tmp.Width;

       if (source is TLabelNola) then
           Caption      := TLabelNola(tmp).caption
       else
           Caption      := '<middle>'+tmp.Caption;
  end
  else
  if (Source is TComboBox) or (Source is TComboBoxXY) then
  begin
       tmpCombo := TComboBox(source);
       Alignment    := taLeftJustify;
       AutoSize     := False;
       Layout       := tlCenter;
       ShowAccelChar:= False;
       Transparent  := False;
       WordWrap     := False;
       Align        := tmpCombo.Align;
       Color        := tmpCombo.Color;
       ControlState := tmpCombo.ControlState;
       ControlStyle := tmpCombo.ControlStyle;
       Cursor       := tmpCombo.Cursor;
       DragCursor   := tmpCombo.DragCursor;
       DragMode     := tmpCombo.DragMode;
       Enabled      := tmpCombo.Enabled;
       Font         := tmpCombo.Font;
       Height       := tmpCombo.Height ;
       Hint         := tmpCombo.Hint;
       Left         := tmpCombo.Left;
       ParentColor  := tmpCombo.ParentColor;
       ParentFont   := tmpCombo.ParentFont;
       ParentShowHint:= tmpCombo.ParentShowHint;
       PopupMenu    := tmpCombo.PopupMenu;
       ShowHint     := tmpCombo.ShowHint;
       Top          := tmpCombo.Top;
       Width        := tmpCombo.Width;
       Caption      := '<middle>'+tmpCombo.Text;
  end
  else
  if (Source is TMaskEdit) or (Source is TEdit) then
  begin
       tmpEdit := TEdit(source);
       Alignment    := taLeftJustify;
       AutoSize     := tmpEdit.AutoSize;
       Layout       := tlCenter;
       ShowAccelChar:= False;
       Transparent  := False;
       WordWrap     := False;
       Align        := tmpEdit.Align;
       Color        := tmpEdit.Color;
       ControlState := tmpEdit.ControlState;
       ControlStyle := tmpEdit.ControlStyle;
       Cursor       := tmpEdit.Cursor;
       DragCursor   := tmpEdit.DragCursor;
       DragMode     := tmpEdit.DragMode;
       Enabled      := tmpEdit.Enabled;
       Font         := tmpEdit.Font;
       Height       := tmpEdit.Height;
       Hint         := tmpEdit.Hint;
       Left         := tmpEdit.Left + BORDER;
       ParentColor  := tmpEdit.ParentColor;
       ParentFont   := tmpEdit.ParentFont;
       ParentShowHint:= tmpEdit.ParentShowHint;
       PopupMenu    := tmpEdit.PopupMenu;
       ShowHint     := tmpEdit.ShowHint;
       Top          := tmpEdit.Top + BORDER;
       Width        := tmpEdit.Width - BORDER;
       Caption      := '<middle>'+tmpEdit.Text;
  end
  else
      inherited Assign(Source);
end;

procedure TLabelNola.WriteLeft(value: integer);
begin
  if (left <> value) then
  begin
    inherited left := value;
    SetDesignInformation;
  end;
end;

procedure TLabelNola.WriteTop(value: integer);
begin
  if (Top <> value) then
  begin
    inherited Top := value;
    SetDesignInformation;
  end;
end;

procedure TLabelNola.WriteWidth(value: integer);
begin
  if (Width <> value) then
  begin
     inherited Width := value;
     SetDesignInformation;
  end;
end;

procedure TLabelNola.WriteHeight(value: integer);
begin
  if (Height <> value) then
  begin
     inherited Height := value;
     SetDesignInformation;
  end;
end;

procedure TLabelNola.WriteAutosize(value: boolean);
begin
  if (Autosize <> value) then
  begin
     inherited Autosize := value;
     UpdateMetafile;
  end;
end;

function  TLabelNola.ReadLeft: integer;
begin
     result := inherited left;
     SetDesignInformation;
end;

function  TLabelNola.ReadTop: integer;
begin
     result := inherited Top;
     SetDesignInformation;
end;

function  TLabelNola.ReadWidth: integer;
begin
     result := inherited Width;
     SetDesignInformation;
end;

function  TLabelNola.ReadHeight: integer;
begin
     result := inherited Height;
     SetDesignInformation;
end;

function  TLabelNola.ReadAutosize: boolean;
begin
     result := inherited Autosize;
end;

procedure   TLabelNola.SetDesignInformation;
begin
     if (csDesigning in ComponentState) then
     begin
          designScreenHeight := Screen.Width;
          designScreenWidth  := Screen.Height;
     end;
end;

procedure TLabelNola.WriteDesignScreenWidth(value: integer);
begin
     if (csDesigning in ComponentState) then
     begin
          FdesignScreenWidth  := Screen.Width;
     end
     else
     begin
          FDesignScreenWidth  := value;
     end;
end;
procedure TLabelNola.WriteDesignScreenHeight(value: integer);
begin
     if (csDesigning in ComponentState) then
     begin
          FdesignScreenHeight  := Screen.Height;
     end
     else
     begin
          FDesignScreenHeight  := value;
     end;
end;

procedure   TLabelNola.PaintTo(canvas: TCanvas; left, top: integer);
begin
     paint;
     canvas.Draw(left, top, metafile);
end;

end.
