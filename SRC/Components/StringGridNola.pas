{
* Copyright (c) 2020, Reijo Pursiainen, Hannu Pursiainen
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of Reijo Pursiainen, Hannu Pursiainen nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY REIJO PURSIAINEN, HANNU PURSIAINEN AND
* CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
* BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL REIJO PURSIAINEN,
* HANNU PURSIAINEN AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
}

///////////////////////////////////////////////////////////////////////////////
//
// FileName:  RichEditNola.pas
// Location:  src\components
// Abstract:  StringGrid that can be controlled by text-tags. (see NolaComp.pas).
//
///////////////////////////////////////////////////////////////////////////////
//
// Following fields are automatically generated by the version control system:
//
// $Revision: 1.5 $
//     $Date: 2005/10/14 17:42:11 $
//
///////////////////////////////////////////////////////////////////////////////
//
// Change Log. Old log entries can be removed by deleting them.
// $Log: StringGridNola.pas,v $
// Revision 1.5  2005/10/14 17:42:11  DEVELOPER2
// Optimointia: käydään vain taulukko kulmasta kulmaan eikä joka solua
//
// Revision 1.4  2005/10/13 18:38:03  DEVELOPER2
// Lisätty optimoiniin takia ForceDimensionEvents
//
// Revision 1.3  2005/10/09 13:59:39  DEVELOPER2
// Reijolta 26.9.2005
//
// 
// 6     25.02.04 20:23 DEVELOPER2
// Reijolta 25.2.2004
// 
// 5     31.07.02 9:46 DEVELOPER2
// - New file header.
// - String parameters to consts
//
// 1    16.05.01 18:50 DEVELOPER2
// initial revision
//
// 2    20.05.01 18:50 DEVELOPER2
// Selection-property handling was corrected
//
// 3    20.05.01 18:50 DEVELOPER2
// Bug fix: Cell was painted with white when selected if the SelectionEnabled was set to false.

unit StringGridNola; {- Tämä on DEVELOPER2 StringGridNola-DEVELOPER2-403.pas -tiedostosta muokattu omalla ohjelmalla
                        E:\ProjektitKoe\DelTextLF\DelTextLFproj.EXE :lla, joka POISTAA YLIMÄÄR. TYHJÄT VÄLIRIVIT.
                      - Muuten sama kuin 12.7.2001, mutta DEVELOPER1 lisännyt DEVELOPER2:n korjaamille riveille
                        "+4.0.DEVELOPER2", omat muutokset "DEVELOPER1" }
interface

uses
  Windows, Messages, SysUtils, Classes, vcl.Graphics, Vcl.Controls, Vcl.Forms, Vcl.Dialogs,
  Vcl.Grids, NolaComp, System.UITypes;

type
  TCellTextEntry = class(TObject)
  private
        text: string;
        font: TFont;
        rect: TRect;
        x: integer;
        y: integer;
  protected
  public
    constructor Create(atext: string; aResult: TParseResult; ax, ay: integer; arect: TRect);
    destructor  Destroy; override;
  end;

  TCellEntry = class(TObject)
  private
         text:         string;
         textList:     TList;
         width:        integer;
         height:       integer;
         State:        TGridDrawState;
         RealWidth:    integer;
         RealHeight:   integer;
         SpanWidth:    integer;
         cellCol:      integer;
         cellRow:      integer;

         { Spannings }
         ColspanMaster:  TCellEntry;
         ColspanClients: TList;

  protected
  public
    constructor Create(ACol, ARow: integer);
    destructor  Destroy; override;
    procedure   AddHeadTextEntry(entry: TCellTextEntry);
    function    GetCount: integer;
    function    GetTextEntry(index: integer): TCellTextEntry;
    function    DeleteHeadTextEntry: TCellTextEntry;
    procedure   Clear;
    procedure   RemoveClients;
    procedure   RemoveClient(client: TCellEntry);
    procedure   RemoveMaster(master: TCellEntry);
    procedure   AddClient(client: TCellEntry);
    procedure   AddMaster(master: TCellEntry);
  end;

  TChangeBordersEvent = procedure(Sender: TObject; ACol, ARow: longint; newWidth, newHeight: integer)
                        of object;
  THighestColInRowEvent    = procedure(Sender: TObject; ACol, ARow: longint; newHeight: integer)
                        of object;
  TWidestColInRowEvent = procedure(Sender: TObject; ACol, ARow: longint; newWidth: integer)
                        of object;

  TOnAfterPaintEvent = procedure(Sender: TObject) of object;

  TStringGridNola = class(TStringGrid)
  private
    defaultColor: TColor;
    defaultFont: TFont;
    rowBuffer: TList;
    emptyCell: TCellEntry;
    results: TParseResults;
    borderRowList: TList;
    borderColList: TList;
    funcTimeStart: TDateTime;
    funcTimeTotal: TDateTime;
    originalOptions: TGridOptions;                //< +4.0.DEVELOPER2

    FOnChangeBorders: TChangeBordersEvent;
    FOnHighestColInRow: THighestColInRowEvent;
    FOnWidestColInRow: TWidestColInRowEvent;
    FOnAfterPaint: TOnAfterPaintEvent;
    FSelectionEnabled: Boolean;
    FAlign: TAlign;
    FValign: TVAlign;
    lastRowCount, lastColCount: integer;

    { Private declarations }
    function  IsChanged(ACol, ARow: integer; rect: TRect): Boolean;
    function  GetCellEntry(ACol, ARow: integer): TCellEntry;
    function  UpdateCellMetafile(destCanvas: TCanvas; ACol,ARow: Longint;
                                 ARect: TRect; AState: TGridDrawState): TRect;
    function  getWidestRowInCol(ACol:integer): integer;
    function  getHighestColInRow(ARow:integer): integer;
    procedure setCellHeight(entry: TCellEntry; height: integer);
    procedure setCellWidth(entry: TCellEntry; width: integer);
    procedure SetColWidths(Index: Longint; Value: Integer);
    function  GetColWidths(Index: Longint): integer;
    procedure SetRowHeights(Index: Longint; Value: Integer);
    function  GetRowHeights(Index: Longint): integer;

    procedure DrawCellToCanvas(source: TCellEntry; dest: TCanvas; DestRect: TRect
                         ; AState: TGridDrawState);
    procedure   WriteCells(ACol, ARow: integer; const text: string);
    procedure   UpdateCell(ACol, ARow: integer; entry: TCellEntry);
    function    ReadCells(ACol, ARow: integer): string;
    procedure   RemoveNullEntries;
    function    CreateColspan(ACol, ARow, colsToSpan: integer; var limit: TRect): integer;
    procedure   DeleteColspan(ACol, ARow: integer);
    procedure   UpdateRow(row: integer);
    procedure   UpdateCol(col: integer);

    procedure   WriteSelectionEnabled(bEnabled: boolean);                               //< +4.0.DEVELOPER2
    procedure   WriteOptions(sOptions: TGridOptions);                                   //< +4.0.DEVELOPER2
    function    ReadOptions: TGridOptions;                                              //< +4.0.DEVELOPER2

  protected
    { Protected declarations }
    procedure DrawCell(ACol,ARow: Longint; ARect: TRect; AState: TGridDrawState); override;
    procedure Paint; override;
    procedure MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer); override;

  public
    { Public declarations }

    constructor Create(Owner: TComponent); override;
    destructor  Destroy; override;
    procedure   Assign(Source: TPersistent); override;
    procedure   FuncStart;
    procedure   FuncEnd;
    function    GetFuncTime: TDateTime;
    function    GetMaxWidth: integer;
    function    GetMaxHeight: integer;
    function    GetFirstEmptyRow(firstCol: integer): integer;
    procedure   ForceDimensionEvents;
    property Cells[ACol, ARow: Integer]: string read ReadCells write WriteCells;
    property ColWidths[Index: Longint]: Integer read GetColWidths write SetColWidths;
    property RowHeights[Index: Longint]: Integer read GetRowHeights write SetRowHeights;

  published
    { Published declarations }
    property OnChangeBorders: TChangeBordersEvent read FOnChangeBorders write FOnChangeBorders;
    property OnHighestColInRow:    THighestColInRowEvent read FOnHighestColInRow write FOnHighestColInRow;
    property OnWidestColInRow:     TWidestColInRowEvent read FOnWidestColInRow write FOnWidestColInRow;
    property OnAfterPaint:         TOnAfterPaintEvent read FOnAfterPaint write FOnAfterPaint;
    property SelectionEnabled:     Boolean read FSelectionEnabled write WriteSelectionEnabled;
    property DefaultCellAlign:     TAlign read FAlign    write FAlign;
    property DefaultCellVAlign:    TVAlign read FValign   write FValign;
    property Options:              TGridOptions read ReadOptions write WriteOptions;    //< +4.0.DEVELOPER2

  end;
     function  compareHeights(item1, item2: TCellEntry): integer;
     function  compareWidths(item1, item2: TCellEntry): integer;

procedure Register;

implementation

procedure Register;
begin
  RegisterComponents('Nola', [TStringGridNola]);
end;

constructor TCellEntry.Create(ACol, ARow: integer);
begin
     text      := '';
     textList  := nil;
     width  := 0;
     height := 0;
     RealWidth  := 0;
     RealHeight := 0;
     State      := [];
     cellCol        := ACol;
     cellRow        := ARow;

     ColspanMaster  := nil;
     ColspanClients := nil;
end;

destructor TCellEntry.Destroy;
begin
     Clear;

     if textList <> nil then
        textList.Destroy;

     if colspanClients <> nil then
     begin
          RemoveClients;
          colspanclients.destroy;
     end;

     if colspanmaster <> nil then
        colspanmaster.RemoveClient(self);

     inherited;
end;

procedure   TCellEntry.AddClient(client: TCellEntry);
begin
     if colspanclients = nil then
        colspanclients := TList.Create;

     colspanclients.Add(client);
end;

procedure   TCellEntry.AddMaster(master: TCellEntry);
begin
     RemoveMaster(colspanmaster);

     colspanmaster := master;
end;

procedure   TCellEntry.RemoveClient(client: TCellEntry);
var
   x: integer;
begin
     if colspanclients <> nil then
     begin
          x := 0;
          while ( x  <   colspanclients.count) do
          begin
               if (colspanclients[x] = client) then
                  colspanclients.delete(x)
               else
                   x := x +1;
          end;
     end;
end;

procedure   TCellEntry.RemoveClients;
var
   x: integer;
begin
     if colspanClients <> nil then
     begin
          for x:= 0 to colspanClients.Count - 1 do
              if (colspanClients[x] <> nil) then
                 TCellEntry(colspanClients[x]).RemoveMaster(self);

          colspanclients.Clear;
     end;
end;

procedure   TCellEntry.RemoveMaster(master: TCellEntry);
begin
     if master = colspanmaster then
        colspanmaster := nil;
end;

procedure TCellEntry.Clear;
var
   x: integer;
begin
     if textList <> nil then
     begin
          for x:= 0 to textList.count - 1 do
              TCellTextEntry(textList.items[x]).destroy;

          textList.Clear;
     end;

     { RemoveClients;

     if colspanmaster <> nil then
     begin
        colspanmaster.RemoveClient(self);
        colspanmaster := nil;
     end; }
end;

procedure   TCellEntry.AddHeadTextEntry(entry: TCellTextEntry);
begin
     if textList = nil then
     begin
          textList  := TList.Create;
          textList.clear;
     end;

     textList.Add(entry);
end;

function    TCellEntry.GetTextEntry(index: integer): TCellTextEntry;
begin
     if (textList <> nil) and
        (textList.count > index) then
        Result := TCellTextEntry(textList[index])
     else
         Result := nil;
end;

function   TCellEntry.DeleteHeadTextEntry: TCellTextEntry;
begin
     if (textList <> nil) and
        (textList.count > 0) then
     begin
        Result := TCellTextEntry(textList.last);
        textList.Delete(textList.count - 1);
     end
     else
         Result := nil;
end;

function    TCellEntry.GetCount: integer;
begin
     if textList <> nil then
        Result := textList.count
     else
         Result := 0;
end;

constructor TCellTextEntry.Create(atext: string; aResult: TParseResult;
                                  ax, ay: integer; arect: TRect);
begin
     text := atext;
     font := TFont.Create;
     aResult.AssignTo(font);
     x := ax;
     y := ay;
     rect := arect;
end;

destructor  TCellTextEntry. Destroy;
begin
     font.destroy;
end;

constructor TStringGridNola.Create(Owner: TComponent);
begin
     funcTimeTotal := 0;
     lastRowCount  := 0;
     lastColCount  := 0;

     defaultCellAlign  := alLeft;
     defaultCellValign := alAbove;

     inherited;

     borderRowList := TList.Create;
     borderColList := TList.Create;

     borderRowList.Clear;
     borderColList.Clear;

     defaultColor:= Canvas.Brush.Color;
     defaultFont := TFont.Create;
     defaultFont.Assign(self.font);

     emptyCell := TCellEntry.Create(0,0);

     { Create buffer }
     rowBuffer := TList.Create;
     rowbuffer.Clear;

     { Font list for recursion }
     results := TParseResults.Create;
     results.Clear;

     // Read and store default options                                                  //< +4.0.DEVELOPER2 muutos..
     originalOptions := options;                                                        //< +4.0.DEVELOPER2 ........
end;

destructor TStringGridNola.Destroy;
var
   x, y: integer;
begin
     for x:= 0 to borderRowList.Count - 1 do
         if borderRowList.Items[x] <> nil then
            TList(borderRowList.Items[x]).destroy;

     for x:= 0 to borderColList.Count - 1 do
         if borderColList.Items[x] <> nil then
            TList(borderColList.Items[x]).destroy;

     borderRowList.Destroy;
     borderColList.Destroy;
     results.Destroy;
     emptyCell.Destroy;

     for x:= 0 to rowBuffer.Count - 1 do
         if rowBuffer[x] <> nil then
            for y:= 0 to TList(rowBuffer[x]).Count - 1 do
                if TList(rowBuffer[x])[y] <> nil then
                   TCellEntry(TList(rowBuffer[x])[y]).destroy;

     rowbuffer.Destroy;

     defaultFont.Destroy;
     inherited;
end;

procedure TStringGridNola.Assign(Source: TPersistent);
var
  row, col: integer;
  grid: TStringGrid;
  gridNola: TStringGridNola;
begin
  if (Source is TStringGridNola) then
  begin
       gridNola := TStringGridNola(source);

       parent   := gridNola.parent;
       rowcount := gridNola.rowcount;
       colcount := gridNola.colcount;

       DefaultColWidth  := gridNola.DefaultColWidth;
       DefaultDrawing   := gridNola.DefaultDrawing;
       DefaultRowHeight := gridNola.DefaultRowHeight;
       DefaultCellAlign := gridNola.DefaultCellAlign;
       DefaultCellVAlign := gridNola.DefaultCellVAlign;

       for col := 0 to colCount - 1 do
           colWidths[col] := gridNola.colWidths[col];

       for row := 0 to rowCount - 1 do
           rowHeights[row] := gridNola.rowHeights[row];

       for row := 0 to rowcount - 1 do
           for col := 0 to colcount - 1 do
                Cells[col, row] := gridNola.cells[col,row];

       BorderStyle      := gridNola.borderStyle;
       EditorMode       := gridNola.EditorMode;
       FixedColor       := gridNola.FixedColor;
       FixedCols        := gridNola.FixedCols;
       FixedRows        := gridNola.FixedRows;
       gridLineWidth    := gridNola.gridLineWidth;
       LeftCol          := gridNola.LeftCol;
       Options          := gridNola.Options;
       ScrollBars       := gridNola.ScrollBars;
       Selection        := gridNola.Selection;

       for col := 0 to colcount - 1 do
           TabStops[col]         := gridNola.TabStops[col];
       TopRow           := gridNola.TopRow;
       Ctl3D            := gridNola.Ctl3D;
       HelpContext      := gridNola.HelpContext;
       ParentCtl3D      := gridNola.ParentCtl3D;
       TabOrder         := gridNola.TabOrder;
       TabStop          := gridNola.TabStop;
       Align            := gridNola.Align;
       Color            := gridNola.Color;
       ControlState     := gridNola.ControlState;
       ControlStyle     := gridNola.ControlStyle;
       Cursor           := gridNola.Cursor;
       DragCursor       := gridNola.DragCursor;
       DragMode         := gridNola.DragMode;
       Enabled          := gridNola.Enabled;
       Font             := gridNola.Font;
       Height           := gridNola.Height;
       Hint             := gridNola.Hint;
       Left             := gridNola.Left;
       ParentColor      := gridNola.ParentColor;
       ParentFont       := gridNola.ParentFont;
       ParentShowHint   := gridNola.ParentShowHint;
       PopupMenu        := gridNola.PopupMenu;
       ShowHint         := gridNola.Showhint;
       Top              := gridNola.Top;
       Width            := gridNola.Width;
  end
  else
  if (Source is TStringGrid) then
  begin
       grid := TStringGrid(source);

       DefaultColWidth  := grid.DefaultColWidth;
       DefaultRowHeight := grid.DefaultRowHeight;
       DefaultDrawing   := grid.DefaultDrawing;

       parent   := grid.parent;
       rowcount := grid.rowcount;
       colcount := grid.colcount;

       for col := 0 to colCount - 1 do
           colWidths[col] := grid.colWidths[col];

       for row := 0 to rowCount - 1 do
           rowHeights[row] := grid.rowHeights[row];

       for row := 0 to rowcount - 1 do
           for col := 0 to colcount - 1 do
                Cells[col, row] := grid.cells[col,row];

       BorderStyle      := grid.borderStyle;
       EditorMode       := grid.EditorMode;
       FixedColor       := grid.FixedColor;
       FixedCols        := grid.FixedCols;
       FixedRows        := grid.FixedRows;
       GridLineWidth    := grid.GridLineWidth;
       LeftCol          := grid.LeftCol;
       Options          := grid.Options;
       ScrollBars       := grid.ScrollBars;
       Selection        := grid.Selection;

       for col := 0 to colcount - 1 do
           TabStops[col]         := grid.TabStops[col];
       TopRow           := grid.TopRow;
       Ctl3D            := grid.Ctl3D;
       HelpContext      := grid.HelpContext;
       ParentCtl3D      := grid.ParentCtl3D;
       TabOrder         := grid.TabOrder;
       TabStop          := grid.TabStop;
       Align            := grid.Align;
       Color            := grid.Color;
       ControlState     := grid.ControlState;
       ControlStyle     := grid.ControlStyle;
       Cursor           := grid.Cursor;
       DragCursor       := grid.DragCursor;
       DragMode         := grid.DragMode;
       Enabled          := grid.Enabled;
       Font             := grid.Font;
       Height           := grid.Height;
       Hint             := grid.Hint;
       Left             := grid.Left;
       ParentColor      := grid.ParentColor;
       ParentFont       := grid.ParentFont;
       ParentShowHint   := grid.ParentShowHint;
       PopupMenu        := grid.PopupMenu;
       ShowHint         := grid.Showhint;
       Top              := grid.Top;
       Width            := grid.Width;
  end
  else
      inherited Assign(Source);
end;

procedure TStringGridNola.FuncStart;
begin
     funcTimeStart := time;
end;

procedure TStringGridNola.FuncEnd;
begin
     funcTimeTotal := functimeTotal + time - funcTimeStart;
     funcTimeStart := 0;
end;

function  TStringGridNola.GetFuncTime: TDateTime;
begin
     GetFuncTime := funcTimeTotal;
end;

procedure   TStringGridNola.UpdateCell(ACol, ARow: integer; entry: TCellEntry);
var
   col, row, width, height: integer;
   state: TGridDrawState;
begin
     state := [];

     if (ACol < FixedCols) then
        state := [gdFixed];

     if (ARow < FixedRows) then
        state := [gdFixed];

     UpdateCellMetafile(self.canvas, ACol, ARow, CellRect(ACol, ARow), state);

     if (Assigned(OnWidestColInRow)) then
     begin
          row   := GetWidestRowInCol(Acol);
          entry := GetCellEntry(Acol, row);
          width := entry.RealWidth;
          if  (colWidths[Acol] <> width) then
              FOnWidestColInRow(self, Acol, row, width);
     end;

     if (Assigned(OnHighestColInRow)) then
     begin
          col := GetHighestColInRow(Arow);
          entry := GetCellEntry(col, Arow);
          height := entry.RealHeight;
          if (rowHeights[Arow] <> height) then
             FOnHighestColInRow(self, col, Arow, height);
     end;
end;

procedure   TStringGridNola.WriteCells(ACol, ARow: integer; const text: string);
var
   entry, client: TCellEntry;
   x: integer;
begin
     // FuncStart;
     entry :=  GetCellEntry(ACol, ARow);

     if (text <> entry.text) then
     begin
          entry.text := text;

          UpdateCell(ACol, ARow, entry);

          if (entry.colspanClients <> nil) and
             (entry.colspanClients.count > 0) then
          begin
               for x:=(entry.colspanclients.count - 1) downto 0 do
               begin
                    client := TCellEntry(entry.colspanclients[x]);
                    cells[client.cellCol, client.cellrow] := ' ';
                    cells[client.cellCol, client.cellrow] := '';
               end;
          end
     end;

     self.setEditText(ACol, ARow, text);
     // FuncEnd;
end;

function    TStringGridNola.ReadCells(ACol, ARow: integer): string;
begin
     result := GetCellEntry(ACol, ARow).text;
end;

procedure TStringGridNola.Paint;
begin
     {Poistetaan ylimääräiste cellEntryt }
     RemoveNullEntries;

     inherited;

     if (Assigned(OnAfterPaint)) then
        FOnAfterPaint(self);
end;

procedure TStringGridNola.RemoveNullEntries;
begin
  { if (colCount < lastColCount) or
      (rowCount < lastRowCount) then
   begin
        for x:= rowCount to borderRowList.count - 1 do
            if (borderRowList[x] <> nil) then
               TList(borderRowList[x]).Destroy;

        for x:= 0 to rowCount - 1 do
            if (borderRowList.Count > x) and             // Korjaus
               (borderRowList[x] <> nil) then
               TList(borderRowList[x]).count := colCount;

        for x:= colCount to borderColList.count - 1 do   // Korjaus
            if borderColList[x] <> nil then
               TList(borderColList[x]).Destroy;

        for x:= 0 to colCount - 1 do
            if (borderColList.count > x) and             // Korjaus
               (borderColList[x] <> nil) then
               TList(borderColList[x]).count := rowCount;

        for x:= rowCount to rowBuffer.count - 1 do
        begin
            if rowBuffer[x] <> nil then
            begin
                 for index := 0 to TList(rowBuffer[x]).count - 1 do
                     if TList(rowBuffer[x])[index] <> nil then
                        TCellEntry(TList(rowBuffer[x])[index]).destroy;

                 if (x < borderRowList.count) and
                    (borderRowList[x] <> nil) then
                    TList(borderRowList[x]).Destroy;
            end;
        end;

        for x:= 0 to rowcount - 1 do
        begin
            if rowBuffer[x] <> nil then
            begin
                 for index := colCount to TList(rowBuffer[x]).count - 1 do
                     if TList(rowBuffer[x])[index] <> nil then
                        TCellEntry(TList(rowBuffer[x])[index]).destroy;
            end;
        end;
   end;

   lastRowCount := rowCount;
   lastColCount := colCount; }
end;

procedure TStringGridNola.DrawCell(ACol,ARow: Longint; ARect: TRect; AState: TGridDrawState);
var
   width, height, col, row: integer;
   entry: TCellEntry;
begin
     // FuncStart;
     entry := GetCellEntry(ACol, ARow);

     if (entry.colspanmaster <> nil) then
     begin
          DrawCellToCanvas(nil, self.Canvas, ARect, AState);

          if (IsChanged(ACol, ARow, ARect) = True) then
          begin
             entry.Height := (arect.bottom - arect.Top);
             entry.Width  := (arect.right  - arect.left);

             UpdateCell(entry.colspanmaster.cellCol, entry.colspanmaster.cellrow,
                        entry.colspanmaster);
          end;

          DrawCell(entry.colspanmaster.cellCol, entry.colspanmaster.cellrow,
                   cellrect(entry.colspanmaster.cellCol, entry.colspanmaster.cellrow),
                   AState);
     end
     else
     if (entry.text = '') and
        (cells[ACol, ARow] = '') then
        begin
             entry.height := rowheights[ARow];
             entry.width  := colwidths[ACol];
             DrawCellToCanvas(entry, self.Canvas, ARect, AState)
        end
     else
     begin
          if (IsChanged(ACol, ARow, ARect) = True) then
          begin
               UpdateCellMetaFile(self.canvas, ACol, ARow, ARect, AState);

               if (Assigned(OnWidestColInRow))  then
               begin
                    row   := GetWidestRowInCol(Acol);
                    entry := GetCellEntry(ACol, row);
                    width := entry.RealWidth;
                    if  (colWidths[Acol] <> width) then
                        FOnWidestColInRow(self, Acol, row, width);
               end;

               if (Assigned(OnHighestColInRow))  then
               begin
                    col := GetHighestColInRow(Arow);
                    entry := GetCellEntry(col, ARow);
                    height := entry.RealHeight;
                    if (rowHeights[Arow] <> height) then
                       FOnHighestColInRow(self, col, Arow, height);
               end;
          end;

          entry := GetCellEntry(ACol, ARow);

          DrawCellToCanvas(entry, self.Canvas, ARect, AState);
      end;
     // FuncEnd;
end;

function  compareHeights(item1, item2: TCellEntry): integer;
begin
     if (item1 = nil) and (item2 = nil) then
        Result := 0
     else if item1 = nil then
        Result := -1
     else if item2 = nil then
        Result := 1
     else if item1.RealHeight = item2.RealHeight then
        Result := 0
     else if item1.RealHeight < item2.RealHeight then
          Result := -1
     else
          Result := 1;
end;

function  compareWidths(item1, item2: TCellEntry): integer;
begin
     if (item1 = nil) and (item2= nil) then
        Result := 0
     else if item1 = nil then
        Result := -1
     else if item2 = nil then
        Result := 1
     else if item1.RealWidth = item2.RealWidth then
        Result := 0
     else if item1.RealWidth < item2.RealWidth then
          Result := -1
     else
          Result := 1;
end;

procedure TStringGridNola.setCellHeight(entry: TCellEntry; height: integer);
var
   list: TList;
   index: integer;
begin
     // FuncStart;

     if height <> entry.RealHeight then
     begin
          if entry.cellRow > borderRowList.Count - 1 then
             borderRowList.Count := entry.cellRow + 1;

          if borderRowList.Items[entry.cellRow] = nil then
          begin
               borderRowList.Items[entry.cellRow] := TList.Create;
               TList(borderRowList.Items[entry.cellRow]).Clear;
          end;

          entry.RealHeight := height;
          list  := TList(borderRowList.Items[entry.cellRow]);
          index := list.IndexOf(entry);

          if index = -1 then
             list.Add(entry);

          if list.Count > 1 then
             list.Sort(Addr(compareHeights));
     end;
end;

procedure TStringGridNola.setCellWidth(entry: TCellEntry; width: integer);
var
   list: TList;
   index: integer;
begin
     // FuncStart;

     if entry.realWidth <> width then
     begin
          if entry.cellCol > borderColList.Count - 1 then
          begin
               borderColList.Count := entry.cellCol + 1;
          end;

          if (borderColList.Items[entry.cellCol] = nil) then
          begin
               borderColList.Items[entry.cellCol]:= TList.Create;
               TList(borderColList.Items[entry.cellCol]).Clear;
          end;

          entry.RealWidth := width;

          list := TList(borderColList.Items[entry.cellCol]);
          index := list.IndexOf(entry);

          if index = -1 then
             list.Add(entry);

          if list.Count > 1 then
             list.Sort(Addr(compareWidths));
     end;
     // FuncEnd;
end;

function  TStringGridNola.GetWidestRowInCol(ACol: integer): integer;
var
   list: TList;
   retVal: integer;
begin
     // funcStart;
     if borderColList.Count < ACol + 1 then
        retval := 0
     else if (borderColList.Items[ACol] = nil) then
        retval := 0
     else
         begin
              list := TList(borderColList.Items[ACol]);
              while (list.count > 1) and
                    (TCellEntry(list.last).cellRow >= rowCount) do
                    list.delete(list.count - 1);

              retval := TCellEntry(list.last).cellRow;
         end;

     result := retVal;
     // FuncEnd;
end;

function  TStringGridNola.getHighestColInRow(ARow:integer): integer;
var
   list: TList;
   retVal: Integer;
begin
     // funcStart;

     if borderRowList.Count < ARow + 1 then
        retval := 0
     else if (borderRowList.Items[ARow] = nil) then
        retval := 0
     else
         begin
              list := TList(borderRowList.Items[ARow]);
              while (list.count > 1) and
                    (TCellEntry(list.last).cellCol >= colCount) do
                    list.delete(list.count - 1);

              retval := TCellEntry(list.last).cellCol;
         end;

     result := retVal;

     // funcEnd;
end;

function TStringGridNola.IsChanged(ACol, ARow: integer; rect: TRect): Boolean;
var
   retVal: boolean;
   cellEntry: TCellEntry;
begin
     // funcStart;
     retVal := False;

     cellEntry := GetCellEntry(ACol, Arow);

     if (cellEntry.text <> cells[ACol, ARow]) then
        retVal := True;

     if  ((cellEntry.Height <> (rect.bottom - rect.Top)) or
         (cellEntry.Width  <> (rect.right  - rect.left))) then
        RetVal := True;

     result := retVal;
     // funcEnd;
end;

function  TStringGridNola.GetCellEntry(ACol, ARow: integer): TCellEntry;
var
   rowList: TList;
   entry: TCellEntry;
begin
     if rowBuffer.count <= ARow then
       rowBuffer.count := ARow + 1;

     if rowBuffer[ARow] = nil then
     begin
          rowBuffer[ARow] := TList.Create;
          TList(rowBuffer[ARow]).clear;
     end;

     rowList := TList(rowBuffer[ARow]);

     if rowList.count <= ACol then
        rowList.count :=  ACol + 1;

     if rowList[ACol] = nil then
     begin
          rowList[ACol] := TCellEntry.Create(ACol, ARow);
          TCellEntry(rowList[ACol]).height := rowheights[ARow];
          TCellEntry(rowList[ACol]).width  := colwidths[ACol];
     end;

     entry := TCellEntry(rowList[ACol]);

     Result := entry;
     // funcEnd;    }
end;

procedure TStringGridNola.DrawCellToCanvas(source: TCellEntry; dest: TCanvas; DestRect: TRect
                         ; AState: TGridDrawState);
var                             //DEVELOPER2 korjannut:  Jos SelectionEnabled=FALSE, putsautui [FicedCol,FixedRow] -Celli.
   x: integer;                  //PARANNUSTOIVE:  Options +[goDrawFocusSelected] SAISI VAIKUTTAA, vaikka Selection-
   entry: TCellTextEntry;       //                Enabled lienee MAHD. VANHOJEN SORCIEN OPTIONS -ASETUKSIA VARTN??
   limitRect: TRect;            //'###############################################################################
   bSelected: boolean; // Is the cell currently selected?                       +4.0.DEVELOPER2 VikaKORJAUS
begin
   bSelected := false; // By the default assume that cell is not selected.      +4.0.DEVELOPER2 VikaKORJAUS

     // dest.Draw(DestRect.Left, DestRect.Top, source)
   if gdFixed in astate then                         //<DEVELOPER1: Oli:  if astate = [gdFixed] then.  < +4.0.DEVELOPER2 muutos
      canvas.Brush.Color   := FixedColor
   else if (SelectionEnabled = True) and (gdSelected in astate) then
   begin
      bSelected := true;                          //< The cell is currently selected.
{     if gdSelected in astate  then               //< DEVELOPER1 +5.0.0
      if goDrawFocusSelected in originalOptions   //< DEVELOPER1 +5.0.0
         then canvas.Brush.Color := defaultColor  //< DEVELOPER1 +5.0.0  RowSelect ???
         else }canvas.Brush.Color := clHighlight; //< Draw background with highlighted color
   end
   else
      canvas.Brush.Color   := defaultColor;

   if (source <> nil) and
      (source.colspanClients <> nil) and
      (source.ColspanClients.Count > 0) then
   begin
        destrect.right := destrect.right + source.SpanWidth;
   end;

   // if (source = nil) or (source.colspanmaster = nil) then
    canvas.FillRect(destrect);           //*

   if (source <> nil) and (source.text <> '') and (source.colspanmaster = nil) then
   begin
    for x:= 0 to source.GetCount - 1 do
    begin
        entry := source.GetTextEntry(x);

        if entry <> nil then
        begin
             canvas.font := entry.font;

             // Color is changed if the cell is currently selected
           //if (gdSelected in astate) and not (gdFixed in astate) then                 //< +4.0.DEVELOPER2
             if (bSelected = true) then                                     //< +4.0.DEVELOPER2 VikaKORJAUS
                canvas.font.Color := clHighlightText;

             limitRect.Top    := destRect.Top + entry.rect.Top;
             limitRect.Bottom := destRect.Top + entry.rect.Bottom;
             limitRect.Left   := destRect.Left + entry.rect.Left;
             limitRect.Right  := destRect.Left + entry.rect.Right;

            // canvas.TextOut(destRect.left + entry.x, destRect.Top + entry.y, entry.text);
            canvas.TextRect(limitRect, destRect.left + entry.x, destRect.Top + entry.y, entry.text);
        end;
    end;
   end;
end;

function  TStringGridNola.UpdateCellMetafile(destCanvas: TCanvas; ACol,ARow: Longint;
                                             ARect: TRect; AState: TGridDrawState): TRect;
var
   stop: boolean;
   Text: string;
   temp{, temp2, temp3}: string; //<Never used -6.2.2
   i, ti, len, tag: integer;
   x, xposition: integer;
   y: integer;
   height: integer;
   width: integer;
   currLen: integer;
   highest: integer;
   fromLeft, fromRight: integer;
   dest: TRect;
   limit: TRect;
   overLimit: TRect;
   cellEntry: TCellEntry;
   tmptext: TCellTextEntry;
   limitDirty: Boolean;
 //lineBreak: Boolean;           //<Never used -6.2.2
   colspan: integer;

   currResult, tmpResult: TParseResult;

begin
   // funcStart;
   limitdirty := False;

   currResult := TParseResult.Create;
   tmpResult  := TParseResult.Create;

   FromLeft  := 0;
   FromRight := 0;

   Text := Cells[ACol, ARow];

   cellEntry      := getCellEntry(ACol, ARow);
   cellEntry.text := text;
   cellEntry.Clear;

   results.Clear;
   defaultFont.Assign(font);
   currResult.Assign(defaultfont);
   canvas.Font.Assign(defaultFont);

   xposition := 0;
   x         := 0;
   y         := 0;
   highest   := 0;

   overLimit.Top    :=  99999; // (ARect.Bottom - ARect.Top);
   overLimit.Bottom := -99999; // -(ARect.Bottom - ARect.Top);
   overLimit.Left   :=  99999;// (ARect.Right - ARect.Left);
   overLimit.Right  := -99999; // -(ARect.Right - ARect.Left);

   { Limit }
   Limit.Top    := 0;
   Limit.Bottom := (ARect.Bottom - ARect.Top);
   Limit.Left   := GridLineWidth;
   Limit.Right  := (ARect.Right  - ARect.Left) - GridLineWidth;

   {Limit.Top    := GridLineWidth + 1 ;
   Limit.Bottom := (ARect.Bottom - ARect.Top)  - GridLineWidth - 1;
   Limit.Left   := GridLineWidth + 1;
   Limit.Right  := (ARect.Right  - ARect.Left) - GridLineWidth - 1; }

 {  if limit.Bottom < limit.Top then
      limit.Bottom := limit.Top;

   if limit.Right < limit.Left then
      limit.Right := limit.Left;   }

   cellEntry.width  := ARect.Right  - ARect.Left;
   cellEntry.Height := ARect.Bottom - ARect.Top;

   highest := 0;
   i := 1;

   currResult.halign  := DefaultCellAlign;
   currResult.valign := DefaultCellVAlign;

   tmpResult.Assign(currResult);
   // funcStart;
   currLen := PixelLength(Canvas, tmpResult, results, Text, i , highest);
   // funcEnd;
   i := 1;

   results.clear;

   stop := FALSE;

   len := length(text);

   if (i > len) then stop := TRUE;

   while(stop = FALSE) do
   begin
        // temp2 := Copy(text, i + 1, length(text) - i);
        // funcStart;
        temp  := ParseText(Text, i, currResult, results, tag);
        // funcEnd;
        // temp3 := Copy(text, i, length(text) - i - 1);
        ti := i;

        currResult.AssignTo(canvas.font);

        if (currResult.colspan = TRUE) then
        begin
             colspan := CreateColspan(ACol, ARow, currResult.colcount, limit);
             cellEntry.SpanWidth := colspan;
             currResult.colspan := FALSE;
        end;

        { Check if there is a change in alignment }
        {if (GetTagLen(temp2, LEFT_TAG) <> 0) OR
           (GetTagLen(temp2, RIGHT_TAG) <> 0) OR
           (GetTagLen(temp2, CENTER_TAG) <> 0) OR
           (currLen = -1) then
        begin
             ti := 0;
             xposition := 0;
             // funcStart;
             currLen   := PixelLength(canvas, currResult, results, temp3, ti , highest);
             // funcEnd;
        end
        else
        if (GetTagLen(temp2, ABOVE_TAG) <> 0) OR
           (GetTagLen(temp2, MIDDLE_TAG) <> 0) OR
           (GetTagLen(temp2, BELOW_TAG) <> 0) OR
           (currLen = -1) then
        begin
             ti := 0;
             highest  := 0;
             // funcStart;
             currLen   := PixelLength(canvas, currResult, results, temp3, ti , highest);
             // funcEnd;
        end; }

        if (tag = LEFT_TAG) OR
           (tag = RIGHT_TAG) OR
           (tag = CENTER_TAG) OR
           (currLen = -1) then
        begin
             // ti := 1;
             xposition := 0;
             currLen   := PixelLength(canvas, currResult, results, text, ti , highest);
        end
        else
        if (tag = ABOVE_TAG) OR
           (tag = MIDDLE_TAG) OR
           (tag = BELOW_TAG) OR
           (currLen = -1) then
        begin
             // ti := 1;
             highest  := 0;
             currLen   := PixelLength(canvas, currResult, results, text, ti , highest);
        end;

        if (temp <> '') then
        begin
             width  := canvas.TextWidth(temp);
             height := canvas.TextHeight(temp);

             case (currResult.valign) of
                  alBelow:  y := Limit.Bottom - height ;
                  alMiddle: y := Limit.Bottom - height - Trunc((Limit.Bottom - Limit.Top - highest) div 2)  - 1;
                  alAbove:  y := Limit.Top    + highest - height;
             end;

             case (currResult.halign) of
                  alLeft:
                         begin
                              x := Limit.Left  + xposition ;

                              if (x > Limit.Right - fromRight) then
                              begin
                                 currLen := currLen + (x - Limit.Left - fromLeft);
                                 x := (Limit.Right - fromRight) + xposition;
                              end;
                         end;
                  alCenter: x := Limit.Left  + xposition + Trunc((Limit.Right - Limit.Left - currLen) div 2) + 1;
                  alRight:
                         begin
                              x := Limit.Right - currLen + xposition;

                              if (x <= Limit.Left + fromLeft) then
                              begin
                                 currLen := currLen - ( Limit.Left + fromLeft - x);
                                 x := (Limit.Left + fromLeft) + xposition;
                              end;
                         end;
             end;

             { Make clipping rectangle }
             dest.Top    := y;
             dest.Bottom := y + height;
             dest.Left   := x;
             dest.Right  := x + width;

             { Check that chracter wont be to big }
             CheckLimits(Limit, dest, overLimit);
             limitDirty := True;

             // funcStart;
             tmpText := TCellTextEntry.Create(temp, currResult, x, y, dest);
             cellEntry.AddHeadTextEntry(tmpText);

             // funcEnd;

             xposition := xposition + width;

             case currResult.halign of
                  alRight: if fromRight + width > fromRight then
                                        fromRight := fromRight + width;
                  alLeft:  if fromLeft + width > fromLeft then
                                        fromLeft  := fromLeft  + width;
                  alCenter:
             end;
        end;

        if (i > len) then
           stop := TRUE;
   end;

   if (text = '') or (LimitDirty= False) then
   begin
        setCellWidth(cellEntry, 0);
        setCellHeight(cellEntry, 0);
   end
   else
   begin
        setCellWidth(cellEntry, ARect.Right  - ARect.Left + (overLimit.Right - overLimit.Left));
        setCellHeight(cellEntry, ARect.Bottom - ARect.Top  + (overLimit.Bottom - overLimit.Top));

        {cellEntry.RealWidth  := ARect.Right  - ARect.Left + (overLimit.Right - overLimit.Left);
        cellEntry.RealHeight := ARect.Bottom - ARect.Top  + (overLimit.Bottom - overLimit.Top);}
   end;

   Result := overLimit;
   Results.Clear;

   // funcStart;
   currResult.Destroy;
   tmpResult.Destroy;
   // funcEnd;

   if (cellEntry.colspanMaster <> nil) then
             UpdateCell(cellEntry.colspanmaster.cellCol, cellEntry.colspanmaster.cellrow,
                        cellEntry.colspanmaster);
   // funcEnd;
end;

function TStringGridNola.CreateColspan(ACol, ARow, colsToSpan: integer; var limit: TRect): integer;
var
   master: TCellEntry;
   client: TCellEntry;
   x: integer;
   span: integer;
begin
     DeleteColspan(ACol, ARow);

     master      := getCellEntry(ACol, ARow);

     span := 0;

     for x := 1 to colsToSpan do //DEVELOPER1
     begin
          client := getCellEntry(ACol + x, ARow);
          client.AddMaster(master);
          master.AddClient(client);

          span := span + client.width;
     end;

     limit.right := limit.right + span;

     result := span;
end;

procedure TStringGridNola.DeleteColspan(ACol, ARow: integer);
var
   master: TCellEntry;
begin
     master      := getCellEntry(ACol, ARow);
     master.RemoveClients;
end;

procedure TStringGridNola.MouseDown(Button: TMouseButton; Shift: TShiftState; X, Y: Integer);
begin
     inherited;
end;

function    TStringGridNola.GetMaxWidth: integer;
var
   total,x: integer;
begin
     total := gridLineWidth;
     for x:= 0 to colcount -1  do
         total := total + ColWidths[x] + gridLineWidth;
     result := total + 2;
end;

function    TStringGridNola.GetMaxHeight: integer;
var
   total,x: integer;
begin
     total := 0;

     for x:= 0 to rowcount - 1 do
          total := total + rowheights[x] + gridLineWidth;

     result := total;
end;

procedure TStringGridNola.SetColWidths(Index: Longint; Value: Integer);
var
   prev: integer;
begin
     prev := ColWidths[index];
     inherited ColWidths[index] := value;

     if (prev <> value) then
        UpdateCol(index);
end;

function  TStringGridNola.GetColWidths(Index: Longint): integer;
begin
     result := inherited ColWidths[index];
end;

procedure TStringGridNola.SetRowHeights(Index: Longint; Value: Integer);
var
   prev: integer;
begin
//if index<12  then begin //£uk
     prev := ColWidths[index];
     inherited RowHeights[index] := value;

     if (prev <> value) then
        UpdateRow(index);
//end;//£uk
end;

function  TStringGridNola.GetRowHeights(Index: Longint): integer;
begin
     result := inherited RowHeights[index];
end;

procedure   TStringGridNola.UpdateRow(row: integer);
var
   x: integer;
begin
     for x:= 0 to colcount - 1 do
         UpdateCell(x, row, GetCellEntry(x, row));
end;

procedure   TStringGridNola.UpdateCol(col: integer);
var
   x: integer;
begin
     for x:= 0 to rowcount - 1 do
         UpdateCell(col, x, GetCellEntry(col, x));
end;

function    TStringGridNola.GetFirstEmptyRow(firstCol: integer): integer;
var
   row: integer;
   col: integer;
   empty: boolean;
begin
     for row := RowCount - 1 downto 0  do
     begin
         empty := true;
         for col := firstCol to ColCount -1 do
              if Cells[col, row] <> '' then empty := false;

         if not empty then
         begin
              result := row + 1;
              exit;
         end;
     end;
     result := rowCount;
end;

{*******************************************************************************
 * ForceDimensionEvents
 *
 * Procedure sends OnWidestCollInRow and OnHighestColInRow events for each row and col
 *
 ******************************************************************************}
procedure TStringGridNola.ForceDimensionEvents;
var
   col, tmp, row, width, height: integer;
   entry: TCellEntry;
begin
     row := RowCount - 1;
     if (Assigned(OnWidestColInRow)) then
     begin
          for col := ColCount - 1 downto 0  do
          begin
               row   := GetWidestRowInCol(col);
               entry := GetCellEntry(col, row);
               width := entry.RealWidth;
               if  (colWidths[col] <> width) then
                    FOnWidestColInRow(self, col, row, width);
          end;

          if (row > 0) then
               row := row - 1;
     end;

     tmp := row;

     if (Assigned(OnHighestColInRow)) then
     begin
          for row := RowCount - 1 downto tmp  do
          begin
               col := GetHighestColInRow(row);
               entry := GetCellEntry(col, row);
               height := entry.RealHeight;
               if (rowHeights[row] <> height) then
                    FOnHighestColInRow(self, col, row, height);
          end;
     end;
end;

{******************************************************************************* // +4.0.DEVELOPER2,,,,,,,,
 * WriteSelectionEnabled
 *
 * Function is called when the SelectionEnabled-property is set.
 *
 * @param bEnabled  if True selection is enabled.
 *
 ******************************************************************************}
procedure   TStringGridNola.WriteSelectionEnabled(bEnabled: boolean);
begin
     // Store the status
     FSelectionEnabled := bEnabled;

     // Check if the selection is activated
     if (true = SelectionEnabled) then
     begin
          // Selection is activated so the range selection option has to be
          // added to the options if it was defined in the options that were
          // assigned before.
          if (goRangeSelect in originalOptions) then
          begin
               // Options are assigned directly to TStringGrid object because
               // otherwise WriteOptions-procedure is called and originalOptions
               // are changed.
               inherited options := options + [goRangeSelect];
          end;
     end
     else
     begin
          // Selection was deactivated so the range selection option has to be
          // removed from the options.
          // Options are assigned directly to TStringGrid object because
          // otherwise WriteOptions-procedure is called and originalOptions
          // are changed.
          inherited options := options - [goRangeSelect];
     end;
end;

{******************************************************************************* // +4.0.DEVELOPER2,,,,,,,,
 * WriteOptions
 *
 * Function is called when the options-property is set.
 *
 * @param sOptions  Options for the grid.
 *
 * @see ReadOptions
 *
 ******************************************************************************}
procedure   TStringGridNola.WriteOptions(sOptions: TGridOptions);
begin
     // Store the real options before they are modified so that they can be
     // restored if the selection is enabled in the later phases.
     originalOptions := sOptions;

     // goRangeSelect is not allowed if the selection is not activated
     if (SelectionEnabled = False) then
        sOptions := sOptions - [goRangeSelect];

     // Options are assigned to the TStringGrid object because that is
     // responsible for changing component behavior.
     inherited options := sOptions;
end;

{******************************************************************************* // +4.0.DEVELOPER2,,,,,,,,
 * ReadOptions
 *
 * Function is called when the options-property is read.
 *
 * @return options of the grid
 *
 * @see WriteOptions
 *
 ******************************************************************************}
function   TStringGridNola.ReadOptions: TGridOptions;
begin
     // Options are read from the TStringGrid object
     result := inherited options;
end;

end.
