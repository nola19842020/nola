{
* Copyright (c) 2020, Reijo Pursiainen, Hannu Pursiainen
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of Reijo Pursiainen, Hannu Pursiainen nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY REIJO PURSIAINEN, HANNU PURSIAINEN AND
* CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
* BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL REIJO PURSIAINEN,
* HANNU PURSIAINEN AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
}

///////////////////////////////////////////////////////////////////////////////
//
// FileName:  FormatCable.pas
// Location:  src\edvnj
// Abstract:  Sisältää funktiot Edka-tietotyypin arvojen sijoittamiseksi
//            CablePanelNola-komponenttiin
// ###############################################################################################################
// ###############################################################################################################
// Glob./Localit muuttujat ja yleiskuvaukset, ks. ..Edv\Johto.PAS                                   10.0.4
// ###############################################################################################################
// ###############################################################################################################
///////////////////////////////////////////////////////////////////////////////
//
// Following fields are automatically generated by the version control system:
//
// $Revision: 1.5 $
//     $Date: 2005/10/09 14:00:46 $
//
///////////////////////////////////////////////////////////////////////////////
//
// Change Log. Old log entries can be removed by deleting them.
// $Log: FormatCable.pas,v $
// Revision 1.5  2005/10/09 14:00:46  DEVELOPER2
// Reijolta 26.9.2005
//
// 
// 11    18.08.04 19:48 DEVELOPER2
// Reijolta 2004-08-18
// 
// 7     22.11.03 10:49 DEVELOPER2
// FormatCablePanel()-funktioon lisätty aloitusrivi
//
// 6     9.11.03 15:21 DEVELOPER2
// Korjaus: Tekstit siirretty johto-osan nimen yhteydestä riville 3. 
//
// 5     9.11.03 14:06 DEVELOPER2
// Päivitykset Reijolta 3.11.2003
// 
// 4     2.11.03 12:24 DEVELOPER2
// CableNola otettu käyttöön
// 
// 3     1.08.02 17:11 DEVELOPER2
// String parameters to consts
// 
// 2     16.06.02 14:56 DEVELOPER2
// 7.X.X
//
// 1     10.03.02 12:51 DEVELOPER2

unit FormatCable;

interface

uses
  { Omat unitit }
  Globals,    { Globaalit määritykset }
  Settings,   { Asetusolio }
  TextBase,   { Tekstivarasto }
  TextBaseTexts,
  Defs,       { Yleiset asetukset }
  Y_,
  Unit1,
  CablePanelNola, Johto, PaaVal{Tics+8.0.0},
  sysutils, Math, extctrls, graphics, Windows;

  function  TupToStr(tup: integer): string;
  function  RealToStrForceTail(num: real; isTailBelow1, IsTailAbove1: Boolean; meaningfullDigits: integer; var aTail:integer; limitExp: integer; middle: string): string;
  function  IntgToStr(num: integer; IsTailAbove1: Boolean; meaningfullDigits: integer; limitExp: integer; middle: string): string;
  function  RealToStr(num: real; isTailBelow1, IsTailAbove1: Boolean; meaningfullDigits: integer; limitExp: integer; middle: string): string;
  function  _RealToStr(num: real; isTailBelow1, IsTailAbove1: Boolean; meaningfullDigits: integer; var aTail:integer; limitExp: integer; const middle: string): string;
  function  AikaToStr(sec: real;  const middle: string;  demoajo :Boolean): string;
  function  PoisAikaToStr(sec: real;  const middle: string;  demoajo :Boolean): string;
  function  PoikkiPintaToStr(ppinta: real;  const middle: string;  demoajo :Boolean): string;
  function  SulakeToStr(sulake: real;  const middle: string;  demoajo :Boolean): string;
  function  VirtaToStr(virta: real;  const middle: string;  demoajo :Boolean): string;
  function  PituusToStr(pituus: real;  const middle: string;  demoajo :Boolean;  dim :integer): string;
  function  PitToStr_M(pituus: real;  demoajo :Boolean): string; //+8.0.6
  function  ResistanssiToStr(res: real;  const middle: string;  demoajo :Boolean): string;
  function  LampotilaToStr(lampotila: real;  const middle: string;  demoajo :Boolean): string;
  function  KorjauskerroinToStr(kkerroin: real;  const middle: string;  demoajo :Boolean): string;
  function  ProsenttiToStr(pros: real;  const middle: string;  demoajo :Boolean): string;
  function  KulmaToStr(pros: real;  const middle: string;  demoajo :Boolean): string;
  function  RoundReal(num: real; meaningfullDigits: integer; limitExp: integer): real;
  function  FormatDigits(num: real; meaningfullDigits: integer; limitExp: integer): string;

  // Function formulates string that are displayed in the TCablePanelNola-component.
  // EdvJohto:    information that is printed to panel
  // CablePanel:  the panel that is modified
  // index:       index of the panel
  // startRow:    index of the row where furst text is written
  procedure FormatCablePanel(const EdvJohto: EdvPalstaType;
                             index: integer; var CablePanel: TCablePanelNola;
                             startRow: integer; JohtoType :TJohtoType); //Lisätty JohtoType: DEVELOPER1 7.2.2004 +6.2.2
   function ChkDesimErotin(si :string) :string;                         //<+130.3b

implementation

function ChkDesimErotin(si :string) :string;      VAR d,n :integer;  c :char;      begin //´130.3b
   c := ','; //SysUtils.FormatSettings.DecimalSeparator;
   n := Length(si);                                          //<,,+130.3b .  http://www.nexusdb.com/forums/showthread.php?t=16311 (+12.0.0)
   for d := 1 to n  do
   if (si[d]='.') and (d>1) and (d<=n) and CharInSet(si[d+1], ['0'..'9']) //<Luvun jälkeen pitää olla vielä Nro.
      then begin si[d]:= c;  {WBeep([500,100, 1000,100]);  }end;
   result := si;
end;
///////////////////////////////////////////////////////////////////////////////
function TupToStr(tup: integer): string;
var
   tmp: string;
begin
     tmp := '';

     if (tup - 1000) >= 0 then begin //130.2e:  Oli:  tmp := STYLE_BOLD_BEGIN +COLOR_RED +COLOR_RED +myTextBase.Get(EDV_TUP_T) +COLOR_END +STYLE_BOLD_END; jne.
        tmp := '<b>' +COLOR_RED +'T</f></b>';
        tup := tup - 1000;  end;

     if (tup - 100) >= 0 then begin
        tmp := '<b>' +COLOR_RED +'U</f></b>';
        tup := tup - 100;  end;

     if (tup - 10) >= 0 then begin
        tmp := '<b>' +COLOR_RED +'P</f></b>';
        tup := tup - 10;  end;

     if (tup - 1) >= 0 then begin
        tmp := '<b>' +COLOR_GREEN +'X</f></b>';
        //tup := tup - 1;   //Never used
     end;

     Result := tmp;
end;

///////////////////////////////////////////////////////////////////////////////
function  RoundReal(num: real; meaningfullDigits: integer; limitExp: integer): real;
var
   exp, k: integer;
   tmpNum: extended;
begin
     if (meaningfullDigits = NOLA_INFINITE) then
        result := num
     else if (num = 0) then
        result := 0
     else
     begin;
          tmpNum := abs(num);
          k := 0;

          // Find the multiplier k when 10^k * absNum = 0.xxxxxxx
          if (tmpNum < 0.1) then
          begin
               while(tmpNum < 0.1) do
               begin
                    k := k + 1;
                    tmpNum := tmpNum * 10;
               end;
          end
          else
          begin
               while(tmpNum > 1) do
               begin
                    k := k - 1;
                    tmpNum := tmpNum / 10;
               end;
          end;

          // Now tmpNum = 0.xxxxxxx

          { a = 0.xxxxxx, num = a * 10 ^ x }
          if (meaningFullDigits > -(limitExp + k)) then
             meaningFullDigits := -(limitExp + k);

          tmpNum := tmpNum * power(10, meaningfullDigits);

          { a = xxxxx.yyyy, num = a * 10 (x - meaningfullDigits) }
          tmpNum := Trunc(tmpNum + 0.5);
          exp := -meaningfulldigits - k;
          tmpNum := tmpNum * power(10, exp);

          if (num < 0) then
             result := -tmpNum
          else
             result := tmpNum;
     end;
end;

///////////////////////////////////////////////////////////////////////////////
function  FormatDigits(num: real; meaningfullDigits: integer; limitExp: integer): string;
var
   a: real;
   x, desim, exp: integer;
   res: string;
begin
     if (meaningfullDigits = NOLA_INFINITE) then
     begin
          RtoSD {VolaStr2} (num, 1, 0, res);
     end
     else
     begin
          x := 0;
          a := num;

          if (a = 0) then
          begin
               a := a;
               x := x;
          end
          else
          if (a >= 1) then
          begin
               while (a >= 1) do
               begin
                    a := a / 10;
                    x := x - 1;
               end;
          end
          else
          begin
               while (a < 0.1) do
               begin
                    a := a * 10;
                    x := x + 1;
               end;
          end;

          { a = 0.xxxxxx, num = a * 10 ^ x }
          if (meaningFullDigits > -(limitExp + x)) then
             meaningFullDigits := -(limitExp + x);

          a := a * power(10, meaningfullDigits);

          { a = xxxxx.yyyy, num = a * 10 (x - meaningfullDigits) }
          a := Trunc(a + 0.5);
          exp := -meaningfulldigits - x;
          a := a * power(10, exp);

          desim := meaningfullDigits + x;

          if (desim < 0) then
             desim := 0;

          RtoSD{ VolaStr2} (a, 1, desim, res);
     end;

     result := res;
end;

///////////////////////////////////////////////////////////////////////////////
function IntgToStr(num: integer;
                   IsTailAbove1: Boolean;
                   meaningfullDigits: integer;
                   limitExp: integer;
                   middle: string): string;
var
   atail: integer;
 //tmp: string;   //<DEVELOPER1:  Ei koskaan käytetty -- poistin
begin
     atail := 0;

     if (num >= 1000) and (IsTailAbove1 = TRUE) then
        result := _RealToStr(num, FALSE, isTailAbove1, meaningfullDigits, aTail, limitExp, middle)
     else
     begin
        //tmp := IntToStr(num); //<DEVELOPER1:  Ei koskaan käytetty -- poistin
        result := FormatDigits(num, meaningfullDigits, limitExp) + middle;
        // result := FormatDigits(tmp, meaningfullDigits);
     end;
end;

///////////////////////////////////////////////////////////////////////////////
function RealToStrForceTail(num: real;
                   isTailBelow1, IsTailAbove1: Boolean;
                   meaningfullDigits: integer;
                   var aTail: integer;
                   limitExp: integer;
                   middle: string): string;
begin
     result := _RealToStr(num, isTailBelow1, isTailAbove1, meaningfullDigits, aTail, limitExp, middle);
end;

///////////////////////////////////////////////////////////////////////////////
function RealToStr(num: real;
                   isTailBelow1, IsTailAbove1: Boolean;
                   meaningfullDigits: integer;
                   limitExp: integer;
                   middle: string): string;
var
   aTail: integer;
begin
     atail := 0;
     result := _RealToStr(num, isTailBelow1, isTailAbove1, meaningfullDigits, aTail, limitExp, middle);
end;

///////////////////////////////////////////////////////////////////////////////
function _RealToStr(num: real;
                   isTailBelow1, IsTailAbove1: Boolean;
                   meaningfullDigits: integer;
                   var aTail: integer;
                   limitExp: integer;
                   const middle: string): string;
var
   amp, tmp: real;
   res: string;
   tail: string;
   d :integer{+130.3b};
begin
     tail := '';

     tmp := RoundReal(num, meaningfullDigits, limitExp);
     amp := abs(tmp);
     if (isTailBelow1 = TRUE) or (isTailAbove1 = TRUE) then
     begin
          if (amp >= 1) and (isTailAbove1 = TRUE) then
          begin
               if ((amp >= 1E15) and (aTail = 0)) or (aTail = 15) then
               begin
                    tail := '';
                    aTail := 15;
               end
               else
               if ((amp >= 1E12) and (aTail = 0)) or (aTail = 12)  then
               begin
                    tail := myTextBase.Get(SYMBOLI_TERA);
                    amp := amp / 1E12;
                    limitExp := limitExp - 12;
                    aTail := 12;
               end
               else
               if ((amp >= 1E9) and (aTail = 0)) or (aTail = 9) then
               begin
                    tail := myTextBase.Get(SYMBOLI_GIGA);
                    amp := amp / 1E9;
                    limitExp := limitExp - 9;
                    aTail := 9;
               end
               else
               if ((amp >= 1E6) and (aTail = 0)) or (aTail = 15) then
               begin
                    tail := myTextBase.Get(SYMBOLI_MEGA);
                    amp := amp / 1E6;
                    limitExp := limitExp - 6;
                    aTail := 6;
               end
               else
               if ((amp >= 1E3) and (aTail = 0)) or (aTail = 3) then
               begin
                    tail := myTextBase.Get(SYMBOLI_KILO);
                    amp := amp / 1E3;
                    limitExp := limitExp - 3;
                    aTail := 3;
               end
               else if amp >= 1 then
               begin
                    tail := '';
               end;
          end
          else if (amp < 1) and (isTailBelow1 = TRUE) then
          begin
               if amp = 0 then
               begin
                  tail := '';
               end
               else if ((amp <  1E-12) and (aTail = 0) and (limitExp < -12)) or (aTail = -15) then
               begin
                    tail := '';
                    aTail := -15;
               end
               else if ((amp <  1E-9) and (aTail = 0) and (limitExp < -9)) or (aTail = -12) then
               begin
                    tail := myTextBase.Get(SYMBOLI_PIKO);
                    amp := amp * 1E12;
                    limitExp := limitExp + 12;
                    aTail := -12;
               end
               else
               if ((amp <  1E-6) and (aTail = 0) and (limitExp < -6)) or (aTail = -9) then
               begin
                    tail := myTextBase.Get(SYMBOLI_NANO);
                    amp := amp * 1E9;
                    limitExp := limitExp + 9;
                    aTail := -9;
               end
               else
               if ((amp <  1E-3) and (aTail = 0) and (limitExp < -3)) or (aTail = -6) then
               begin
                    tail := myTextBase.Get(SYMBOLI_MIKRO);
                    amp := amp * 1E6;
                    limitExp := limitExp + 6;
                    aTail := -6;
               end
               else if ((amp > 0) and (aTail = 0) and (limitExp < 0)) or (aTail = -3) then
               begin
                    tail := myTextBase.Get(SYMBOLI_MILLI);
                    amp := amp * 1E3;
                    limitExp := limitExp + 3;
                    aTail := -3;
               end;
          end;
     end;

     if (amp = 0) then
        res := '0'
     else
     if ((amp >= 1000000000) or (amp < 0.00000001)) then
     begin
        //res := format('%e', [amp]);
        //res := FormatDigits(res, meaningfullDigits);
     end
     else
     begin
        // res := format('%.18f', [amp]);
        // res := FormatDigits(res, meaningfullDigits);
     end;
     res := formatDigits(amp, meaningfullDigits, limitExp);

     res := res + middle + tail;

     if (num < 0) then
        result := '-' + res
     else
        result := res;
     if num=0  then result := '0'; //<+6.0.2 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
     d := Length(res);                                          //<,,+130.3b .  http://www.nexusdb.com/forums/showthread.php?t=16311 (+12.0.0)
     for d := 1 to d  do
     if (res[d]<>SysUtils.FormatSettings.DecimalSeparator) and (d>1) //<
        then res[d]:= SysUtils.FormatSettings.DecimalSeparator;
end;//_RealToStr

///////////////////////////////////////////////////////////////////////////////
function AikaToStr(sec: real;  const middle: string;  demoajo :Boolean): string;      VAR s :string;      begin
   //if (demoCheck = TRUE) and (Demö = True) then //-8.0.0
     if demoajo  then begin                       // 8.0.0
        //result := fdemix(1, 0, 1) + ' ';          -8.0.0
          s := sDemI +' ';                      //<,+8.0.0  'Xxx'
          result := s;
          exit;
     end;

     if (sec > 20) then
        Result := '> 20 '
     else
        Result := RealToStr(sec, TRUE, FALSE, 2, SMALLEST_AIKA, middle);
end;

///////////////////////////////////////////////////////////////////////////////
function PoisAikaToStr(sec: real;  const middle: string;  demoajo :Boolean): string;      VAR s :string;    begin
   //if (demoCheck = TRUE) and (Demö = True) then //-8.0.0
     if demoajo  then begin                       // 8.0.0
        //result := fdemix(1, 0, 1) + ' ';          -8.0.0
          s := sDemI +' ';                      //<,+8.0.0  'Xxx'
          result := s;
          exit;
     end;

     Result := RealToStr(sec, FALSE, FALSE, 4, SMALLEST_POISAIKA, middle);
end;

///////////////////////////////////////////////////////////////////////////////
function  PoikkiPintaToStr(ppinta: real;  const middle: string;  demoajo :Boolean): string;    VAR s :string;  begin
                                            //DEVELOPER1 +8.0.0:  Muutettu, jotta pääsee tutkimaan arvoja debuggerilla.
   //if (demoCheck = TRUE) and (Demö = True) then //-8.0.0
     if demoajo  then begin                       // 8.0.0
        //result := fdemix(1, 0, 1) + ' ';          -8.0.0
          s := sDemI +' ';                      //<,+8.0.0  'Xxx'
          result := s;
          exit;
     end;
     if ppinta<2  then ppinta := 1.5  else
     if ppinta<3  then ppinta := 2.5;

     if (ppinta >= 3)
        then s := IntgToStr(Trunc(ppinta), FALSE, NOLA_INFINITE, 1, middle)
        else s := RealToStr(ppinta, FALSE, FALSE, 2, SMALLEST_POIKKIPINTA, middle);

     result := s;
end;

///////////////////////////////////////////////////////////////////////////////
function  SulakeToStr(sulake: real;  const middle: string;  demoajo :Boolean): string;      VAR s :string;   begin
                                             //DEVELOPER1 +8.0.0:  Muutettu, jotta pääsee tutkimaan arvoja debuggerilla.
   //if (demoCheck = TRUE) and (Demö = True) then //-8.0.0
     if demoajo  then begin                       // 8.0.0
        //result := fdemix(1, 0, 1) + ' ';          -8.0.0
          s := sDemI +' ';                      //<,+8.0.0  'Xxx'
          result := s;
          exit;
     end;

     result := IntgToStr(Trunc(sulake + 0.5), FALSE, NOLA_INFINITE, SMALLEST_SULAKE, middle)
end;

///////////////////////////////////////////////////////////////////////////////
function  VirtaToStr(virta: real;  const middle: string;  demoajo :Boolean): string;      VAR s :string;    begin
                                             //DEVELOPER1 +8.0.0:  Muutettu, jotta pääsee tutkimaan arvoja debuggerilla.
   //if (demoCheck = TRUE) and (Demö = True) then //-8.0.0
     if demoajo  then begin                       // 8.0.0
        //result := fdemix(1, 0, 1) + ' ';          -8.0.0
          s := sDemI +' ';                      //<,+8.0.0  'Xxx'
          result := s;
          exit;
     end;

     s := RealToStr(virta, TRUE, TRUE, 4, SMALLEST_VIRTA, middle);
     result := s;
end;

//////////////////////////////////////////////////////////////////////////////,dim>0 =dimensio mukaan
function  PituusToStr_(pituus: real;  const middle: string;  demoajo :Boolean;  dim :integer): string; //8.0.0 => 130.2e
      VAR s :string;                        //<DEVELOPER1 +8.0.0:  Muutettu, jotta pääsee tutkimaan arvoja debuggerilla.
begin
   //if demoCheck and  (boo  or ebo)  then        // 8.0.0
     if demoajo  then begin
        //result := fdemix(1, 0, 1) + ' ';          -8.0.0
          s := sDemI +' ';                      //<,+8.0.0  'Xxx'
          if dim>0  then s := s +myTextBase.Get(SYMBOLI_METRI);
          result := s;
          exit;
     end;

     if pituus=0                                                     //<,,+8.0.0
     then s := myTextBase.Get(EDV_VIRHE)                             //< "----" siirretty tänne Johto.PAS:sta yms.
     else begin
          if (pituus>100) {and (pituus<1000)}  then pituus := trunc(pituus +0.5); //<+130.2e
          s := RealToStr(pituus, FALSE, TRUE, 4, SMALLEST_PITUUS, middle);
          if dim>0  then s := s +{' ' +}myTextBase.Get(SYMBOLI_METRI);
     end;
     result := s;
end;//PituusToStr_
function  PituusToStr(pituus: real;  const middle: string;  demoajo :Boolean;  dim :integer): string;      //VAR rr :real;  s :string;
   procedure typ;   begin end;
begin
                       {s := PituusToStr_(12.4,'',false,1);
   if s<>'' then typ;   s := PituusToStr_(12.5,'',false,1);
   if s<>'' then typ;   s := PituusToStr_(12.6,'',false,1);
   if s<>'' then typ;   s := PituusToStr_(124.4,'',false,1);
   if s<>'' then typ;   s := PituusToStr_(124.5,'',false,1);
   if s<>'' then typ;   s := PituusToStr_(124.6,'',false,1);
   if s<>'' then typ;   s := PituusToStr_(1124.4,'',false,1);
   if s<>'' then typ;   s := PituusToStr_(1124.4,'',false,1);
   if s<>'' then typ;   s := PituusToStr_(1124.4,'',false,1);}
   result := PituusToStr_(pituus,middle,demoajo,dim);
end;
function  PitToStr_M(pituus: real;  demoajo :Boolean): string; //+8.0.6,  130.2e:  Kutsutaan:  FormatCable.PAS/PRC FormatCablePanel´sta.
      VAR s :string;
begin
     if demoajo
     then s := 'Xx.x m'
     else begin
          if pituus >= 1000
        //then s := fRmrkt0 (pituus/1000,1,3) + ' km'
          then s := fRmrkt0 (pituus,1,0) + ' m' //<130.2e.
          else if pituus >= 100
          then s := fRmrkt0 (pituus,1,0) + ' m'
          else s := fRmrkt0 (pituus,1,1) + ' m';
     end;
     result := s;
end;

///////////////////////////////////////////////////////////////////////////////
function  ResistanssiToStr(res: real;  const middle: string;  demoajo :Boolean): string;      VAR s :string;   begin
                                             //DEVELOPER1 +8.0.0:  Muutettu, jotta pääsee tutkimaan arvoja debuggerilla.
   //if (demoCheck = TRUE) and (Demö = True) then //-8.0.0
     if demoajo  then begin                       // 8.0.0
        //result := fdemix(1, 0, 1) + ' ';          -8.0.0
          s := sDemI +' ';                      //<,+8.0.0  'Xxx'
          result := s;
          exit;
     end;

     result := RealToStr(res, TRUE, TRUE, 4, SMALLEST_RESISTANSSI, middle);
end;

///////////////////////////////////////////////////////////////////////////////
function  LampotilaToStr(lampotila: real;  const middle: string;  demoajo :Boolean): string;    VAR s :string;   begin
                                             //DEVELOPER1 +8.0.0:  Muutettu, jotta pääsee tutkimaan arvoja debuggerilla.
   //if (demoCheck = TRUE) and (Demö = True) then //-8.0.0
     if demoajo  then begin                       // 8.0.0
        //result := fdemix(1, 0, 1) + ' ';          -8.0.0
          s := sDemI +' ';                      //<,+8.0.0  'Xxx'
          result := s;
          exit;
     end;

     result := RealToStr(lampotila, FALSE, FALSE, 4, SMALLEST_LAMPOTILA, middle);
end;

///////////////////////////////////////////////////////////////////////////////
function  KorjauskerroinToStr(kkerroin: real;  const middle: string;  demoajo :Boolean): string;
       VAR s :string;      begin             //DEVELOPER1 +8.0.0:  Muutettu, jotta pääsee tutkimaan arvoja debuggerilla.
   //if (demoCheck = TRUE) and (Demö = True) then //-8.0.0
     if demoajo  then begin                       // 8.0.0
        //result := fdemix(1, 0, 1) + ' ';          -8.0.0
          s := sDemI +' ';                      //<,+8.0.0  'Xxx'
          result := s;
          exit;
     end;

     result := RealToStr(kkerroin, FALSE, FALSE, 4, SMALLEST_KORJAUSKERROIN, middle);
end;

///////////////////////////////////////////////////////////////////////////////
function  ProsenttiToStr(pros: real;  const middle: string;  demoajo :Boolean): string;     VAR s :string;   begin
                                             //DEVELOPER1 +8.0.0:  Muutettu, jotta pääsee tutkimaan arvoja debuggerilla.
   //if (demoCheck = TRUE) and (Demö = True) then //-8.0.0
     if demoajo  then begin                       // 8.0.0
        //result := fdemix(1, 0, 1) + ' ';          -8.0.0
          s := sDemI +' ';                      //<,+8.0.0  'Xxx'
          result := s;
          exit;
     end;

     result := RealToStr(pros, FALSE, FALSE, 4, SMALLEST_PROSENTTI, middle);
end;

///////////////////////////////////////////////////////////////////////////////
function  KulmaToStr(pros: real;  const middle: string;  demoajo :Boolean): string;       VAR s :string;     begin
                                             //DEVELOPER1 +8.0.0:  Muutettu, jotta pääsee tutkimaan arvoja debuggerilla.
   //if (demoCheck = TRUE) and (Demö = True) then //-8.0.0
     if demoajo  then begin                       // 8.0.0
        //result := fdemix(1, 0, 1) + ' ';          -8.0.0
          s := sDemI +' ';                      //<,+8.0.0  'Xxx'
          result := s;
          exit;
     end;

     result := RealToStr(pros, FALSE, FALSE, 4, SMALLEST_KULMA, middle);
end;

///////////////////////////////////////////////////////////////////////////////
procedure FormatCablePanel(const EdvJohto: EdvPalstaType; index: integer;
                           var CablePanel: TCablePanelNola; startRow: integer; JohtoType :TJohtoType);
var                                                                     //Lisätty JohtoType: DEVELOPER1 7.2.2004 +6.2.2
   tmp :string;
   rs,zs :real;

   function fPh_Ih :real;      VAR ar,ac :real;      begin //<, I = P*1000 / (Un *cos *V¨3)         +6.0.0
       ac := a_getReaa (101081, EdvJohto.Cosp);      //<Cos voi olla 0 vain, jos FNC ArvotOK ei ole saanut syöttö-
       if ac<=0.01  then ac := 1;                    // arvovirhettä kiinni tai Y_.PAS:ssa fVexN '' => 0, eli muut-
       ar := a_getReaa(101080, EdvJohto.Ph) *1000 / ( Sqrt(3) *fUn *ac);    //ti tyhjän stringin nollaksi. Ei enää.
      result := ar;
   end;

begin
{LIITTYMÄ- JA Edv:n JOHTOPANELI KIRJABTN´in VIERESSÄ:      5xAXCMK 300 mm²
                                                           8.0 m SÄL 80° k=1 ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,}
                             {CABLE_ROW_COUNT = 6;
                                // Määrittelee rivin, josta alaspäin tiedot CablePanelNola-komponentissa kuvaavat
                                // varsinaista johto-osaa eikä liityntäjohtoa.
                                // Muuttamalla tätä arvoa, voidaan johto-osan ensimmäistä riviä siirtää.
                                // Rivit 0-2 varattu liityntäjohdolle
                                // Rivit 3-5 varattu johto-osalle.
                                FIRST_CABLE_ROW = 3;}
Tics ('FormatCablePanel 1');
  //,,,Label1,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
  tmp := EDV_COLOR_FONT_INPUT;
  if (a_getIntg(101011, EdvJohto.lukumaara) > 1) then
    tmp := tmp + IntToStr(a_getIntg(101020, EdvJohto.lukumaara)) + 'x ';

  tmp := tmp + a_getStrg(101013, EdvJohto.tyyppi);
  tmp := tmp + ' ';
  tmp := tmp + PoikkiPintaToStr(a_getReaa(101014, EdvJohto.Amm2), ' ', False); //<LiittymätietoRv [3]
  tmp := tmp + ' ' + myTextBase.Get(SYMBOLI_MILLI);
  tmp := tmp + myTextBase.Get(SYMBOLI_METRI) + '²';
  tmp := ChkDesimErotin(tmp); //<+130.3e

  if(johtoType=JOHTO_LIITTYMA)  and (edv.Sorc[index].src.SorceKind.arvoInt=3{Gener})  then begin //<,,+8.0.8
     tmp := tmp +EDV_COLOR_FONT_JOHTO_HEADER +' IkSus='  +EDV_COLOR_FONT_INPUT +
                 fImrkt0 (edv.Sorc[index].src.gIkSust.arvoInt,1);
     tmp := tmp +EDV_COLOR_FONT_JOHTO_HEADER +' c1v='  +EDV_COLOR_FONT_INPUT +
                 fRmrkt0 (edv.Sorc[index].src.gK1vSust.arvoRea, 1,2);  end;
  //,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,+6.0.0
  rs := a_getReaa(101015, EdvJohto.Ph);
//if johtoType<>JOHTO_LIITTYMA  then                                                               //<,,+6.2.2  -120.5o
//if (rs>0) and ({(index>1) and} (a_getReaa(101016, edv.edka[index-1].Ph) =0)  OR (index=1))  then //<-120.5o:  "(index>1) and"   vex.
//if (rs>0) and (                (a_getReaa(101016, edv.edka[index-1].Ph) =0)  OR (index=1))  then //<-120.5o:  "(index>1) and"   vex.
//if (rs>0) and (                (edv.edka[index-1].Ph.ArvoRea =0)  OR (index=1))  then            //<-120.5o:  "(index>1) and"   vex.
  if rs>0  then                                                                    //'120.5o:  Tulee aina Ohjelmavirhe(NOLAn) kun muuttaa Ph>0, ei
    tmp := tmp +'  ' +COLOR_BLUE +'uho%' +fVexN_(fMrktRaj (EdvJohto.Uho)) +'</f>'; // ilmeisesti ole edv.edka[Edi].Ph.ArvoRea päivittynyt tms!?!?!?.
{if edv.edka[index-1].Ph.ArvoRea<0  then ;
if edv.edka[index].  Ph.ArvoRea<0  then ;
if edv.edka[Edi].    Ph.ArvoRea<0  then ;}
  // label1.caption := tmp; //<Levittää automaattisesti HeaderPanel +Label +LahtoGrid+ SulakeGrid,TODETTU
// DEVELOPER2 2003-11-21 BEGIN
  CablePanel.rows[startRow + 0] := tmp;
// DEVELOPER2 2003-11-21 END

  //,,,Label2,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
  tmp := EDV_COLOR_FONT_INPUT;
(* tmp := tmp + PituusToStr(a_getReaa(101010, EdvJohto.pituus), ' ', False,1) +
         {myTextBase.Get(SYMBOLI_METRI)} ' ';*)
  tmp := tmp + PitToStr_M (a_getReaa(101010, EdvJohto.pituus), False{=ei DemoTest}) +' '; //8.0.6

//  tmp2 := EDV_COLOR_FONT_POHJA_HEADER + '(' + EDV_COLOR_FONT_INPUT;
  if a_getBool(101015, EdvJohto.kuluttaja) = True then
  begin
//    tmp2 := tmp2 + PoisAikaToStr(a_getReaa(101111, TJohdot(johdot).Yle.PoisAika), ' ', False) +
//            myTextBase.Get(SYMBOLI_SEKUNTI);
    tmp := tmp + myTextBase.Get(EDV_KULUTTAJA)
  end
  else
  begin
//    if (EdvJohto.arvo[10] > 63) then
//      tmp2 := tmp2 + myTextBase.Get(EDV_SUOJAUSEHDOT_3)
//    else
//    tmp2 := tmp2 + myTextBase.Get(EDV_SUOJAUSEHDOT_2);
    tmp := tmp + myTextBase.Get(EDV_SAHKOLAITOS);
  end;

//  tmp2 := tmp2 + EDV_COLOR_FONT_POHJA_HEADER + ')';

  //DEVELOPER2 7.12.1998. Absoluuttinen rivi suhteelliseksi EDV_MAX_SULAKKEET_HEADER_ROW_4 nähden
//  SetText(SulakeGrid, EDV_HEADER_COL_0, EDV_MAX_SULAKKEET_HEADER_ROW_4 + 1, tmp2);

  tmp := tmp + ' ';
  tmp := tmp + LampotilaToStr(a_getIntg(101017, EdvJohto.Lampotila), '', False) + '° ';
  tmp := tmp + myTextBase.Get(EDV_JOHTO_KORJAUSKERROIN) +
             //'=' + KorjauskerroinToStr(a_getReaa(101019, EdvJohto.korjaus), '', False);          //<-6.0.0
               '=' + fVexNrd (a_getReaa(101019, EdvJohto.korjaus),3);            //<Loppunollat vex = +6.0.0
                                  //tmp := tmp +'  ' +COLOR_BLUE +'56.34kW</f>';
  rs := a_getReaa(101020, EdvJohto.Ph);
//if johtoType<>JOHTO_LIITTYMA  then                                                            //<+6.2.2 120.5.o:  Nyt myös liittymäjohdolle.
  if rs>0  then //,Levittää automaattisesti HeaderPanel +Label +LahtoGrid+ SulakeGrid,TODETTU
    tmp := tmp +'  ' +COLOR_BLUE +fVexN_(fMrktRaj (EdvJohto.Ph)) +'kW</f>';

  // label2.caption := tmp;
// DEVELOPER2 2003-11-21 BEGIN
  CablePanel.rows[startRow + 1] := tmp;
// DEVELOPER2 2003-11-21 END

  //,,,Label3,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
  tmp := EDV_COLOR_FONT_JOHTO_HEADER;
                                  //tmp := tmp +'<left>' +COLOR_BLUE +'Cos' {+FONT_FII }+'0.853' +
 {if johtoType<>JOHTO_LIITTYMA    //                                 ' uh%'             +'12.32 </f>';//<right>';
  then begin}                                                                           //<+6.2.2 <,,+120.5o: Lisätty uh% myös liittymäjohdolle.
     if rs>0  then begin         //,P = V¨3UICos => c
       tmp := tmp +{'<left>' +}COLOR_BLUE +fImrkt0 (a_getIntg (101020, EdvJohto.Tuh),1) +'°c ';
       zs := fPh_Ih;
       tmp := tmp +fRmrkt0 (zs,1,0) +' A ' +'cos' {+FONT_FII }+fVexN_ (fMrktRaj (EdvJohto.Cosp)) +' uh%';
       if Demo(61)  then tmp := tmp +'X.x'
          else tmp := tmp +{fVexN_(}fMrktRaj (EdvJohto.Uhp); //uh%
                                            {if (edv.Sorc[1].Josa.Uhp.ArvoRea >0) or (edv.Sorc[1].Josa.Uhv.ArvoRea >0) or (edv.Sorc[1].Josa.Uho.ArvoRea >0) or
                                                (edv.Edka[1].Uhp.ArvoRea >0) or (edv.Edka[1].Uhv.ArvoRea >0) or (edv.Edka[1].Uho.ArvoRea >0)  then ;//}
       tmp := tmp +'/uh1v%' +{fVexN_(}fMrktRaj (EdvJohto.Uhv);                                             //'Vex ettei NIL err!?!?
       tmp := tmp +' </f>';//<right>';
     end;                         //''<left>/<right> ei vaikutusta. Ehkä, koska Label3=AutoSize '''''''''''!!!
{ else if johtoType=JOHTO_LIITTYMA
  then begin
   end;}

  rs := a_getReaa (101021, EdvJohto.PEker);             //<,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,+2.0.7
                                  //tmp := tmp +CLR_REB +'Kpe' +'0.72' +FNT_B0;
  if johtoType<>JOHTO_LIITTYMA  then                                                            //<+6.2.2
  if rs<1  then
    tmp := tmp +CLR_REB +'Kpe' +fVexN_ (fMrktRaj (EdvJohto.PEker)) +FNT_B0;
    //tmp := tmp +'<b>NK-A12.888</b>';                         //<Just mahtuu:  PEker=1.00 NK-A12.888
//  Nimi siirretty suoraan CablePanel.name kohtaan ja tmp ilman nimeä tulostetaan riville 3.
//  tmp := tmp +'<b> ' +a_getStrg (101021, EdvJohto.nimi) +'</b>';

  // label3.alignment := taRightJustify; //<Pakko, muuten jää JK:n nimi vex, TODETTU.
  // label3.caption := tmp;
  // Toimintaa muutettu siten, että vain kaapelin nimi näytetään viivan päällä
  // ja muut tekstit näytetään rivillä 3.
  //   CablePanel.Name := tmp;
  tmp := tmp +' '; //<Jotta vähimmillä tiedoilla txt-rivien ollessa 2 pysyisi panelin korkeus vakiona, eikä
                   // DataPaneli työntyisi seur. 3-rivisen tekstin päälle. TODETTU.             +6.2.2
// DEVELOPER2 2003-11-21 BEGIN
  CablePanel.rows[startRow + 2] := tmp;
// DEVELOPER2 2003-11-21 END
 {CablePanel.Name := '<b> ' +a_getStrg (101021, EdvJohto.nimi) +'</b>';            //<,-8.0.0
  CablePanel.ShowPt := a_getBool(101000, EdvJohto.PTLopussa);}

  CablePanel.Name := '';  //CablePanel.Name := IntToStr (Index); //=Koe
                                                          //<Putsataan vanhat +8.0.0
(*if index=edv.YLE.SorceCount.arvoInt  then begin
     CablePanel.Name := '<b> ' +a_getStrg (101021, edv.Sorc[1].Josa.nimi) +'</b>';    //<,8.0.0
    {CablePanel.ShowPt := a_getBool(101000, edv.Sorc[1].Josa.PTLopussa);  EiTarvita}end;*)
  if index=edv.YLE.SorceCount.arvoInt                                                 //<,8.0.0 Jakokeskuksen NIMI/TUNNUS
  then CablePanel.Name := '<b> ' +a_getStrg (101021, edv.Sorc[1].Josa.nimi) +'</b>' //<,-120.5i: CablePanel.Createssa [fsBold] => [] =turvotti nimeä enemmän.
  else if johtoType<>JOHTO_LIITTYMA                                                   //<,+8.0.0 B
  then CablePanel.Name := '<b> ' +a_getStrg (101021, EdvJohto.nimi) +'</b>';        //<,-120.5i: CablePanel.Createssa [fsBold] => [] =turvotti nimeä enemmän.

Tics ('FormatCablePanel 9');
end;//FormatCablePanel

end.

