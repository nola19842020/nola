{
* Copyright (c) 2020, Reijo Pursiainen, Hannu Pursiainen
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of Reijo Pursiainen, Hannu Pursiainen nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY REIJO PURSIAINEN, HANNU PURSIAINEN AND
* CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
* BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL REIJO PURSIAINEN,
* HANNU PURSIAINEN AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
}

//Johdot.PAS / 120.6 -versio.
//#############################################################################
//#############################################################################
//>>>>>>>>>> Johto-osien palstojen leveydet samoiksi etsi GetBiggest.<<<<<<<<<<
//#############################################################################
//#############################################################################
{$IFDEF PROFILE} {$O-} {$WARNINGS OFF} {$ENDIF }
{$M+}
///////////////////////////////////////////////////////////////////////////////
// Sähköinsinööritoimisto Pursiainen oy
// (c) 2003, All Rights Reserved
///////////////////////////////////////////////////////////////////////////////
//
// FileName:  Johdot.pas
// Location:  src\edvnj
// Abstract:  Sisältää edeltävän verkon otsikko gridin ja johto-osat.
// ###############################################################################################################
// ###############################################################################################################
// Glob./Localit muuttujat ja yleiskuvaukset, ks. ..Edv\Johto.PAS                                   10.0.4
// ###############################################################################################################
// ###############################################################################################################
// ###############################################################################################################
// ############################# HeaderGrid on RiviNimiGrid(paneli) edvn vas.laidassa.############################
// #############################'Etsi "HeaderGrid on RiviNimiGrid"################################################
// ###############################################################################################################
// ###############################################################################################################
///////////////////////////////////////////////////////////////////////////////
//
// Following fields are automatically generated by the version control system:
//
// $Revision: 1.9 $
//     $Date: 2005/10/15 08:22:17 $
//
///////////////////////////////////////////////////////////////////////////////
//
// Change Log. Old log entries can be removed by deleting them.
// $Log: Johdot.pas,v $
// Revision 1.9  2005/10/15 08:22:17  DEVELOPER2
// Optimointi: johdot.resize() kutsutaan vain EdvNew modulista tarvittaessa
//
// Revision 1.8  2005/10/15 06:28:14  DEVELOPER2
// Johtojen "välkyntää" lisättäessä vähennetty.
//
// Revision 1.7  2005/10/14 17:59:46  DEVELOPER2
// Optimointia: päivitetään ruutua vain kun on tarve
//
// Revision 1.6  2005/10/09 14:00:46  DEVELOPER2
// Reijolta 26.9.2005
//
// Revision 1.4  2005/08/29 20:12:43  DEVELOPER2
// Korjattu liittymäjohdon lisäys
//
// Revision 1.3  2005/08/29 18:17:53  DEVELOPER2
// reijolta 29.8.2005
//
//
// 23    1.03.04 18:16 DEVELOPER2
// Reijolta 1.3.2004
//
// 22    28.02.04 17:43 DEVELOPER2
// Bug fix. Viimeinen johto ei toiminut oikein, kun johto-osia poistettiin.
// Korjattiin estämällä viimeisen johto-osan tuhoaminen ja päivittämällä
// johtojen indeksit oikeiksi tuhoamisen jälkeen.
//
// 21    28.02.04 13:05 DEVELOPER2
// Reijolta 28.2.2004
//
// 18    16.01.04 22:10 DEVELOPER2
// ArrayIndex korjattu alkamaan 1:sestä.
//
// 17    16.01.04 20:56 DEVELOPER2
// Otettu käyttöön muutettu liittymajohtojen tietorakenne:
// - FSorc: otettu käyttöön ja tyyppi muutettu SorceTypeksi.
// - CreateJohto(): johto uudelleen nimetty locationIndexeksi, arrayIndex
// lisätty, johtojen luomista muutettu.
// - GetLiittymaCount(): GetConnectionCount() uudelleen nimetty
// GetLiittymaCount().
// - GetJohtoOsiaCount(): lisätty liittymäosien lukumääräm lukemista varten.
// - WriteYLE(): var-esittely otettu käyttöön koodin optimoimiseksi, muutettu
// vastaamaan uutta tietorakennetta.
// - WriteSorc(): Otettu käyttöön ja tyyppi muutettu SorceTypeksi.
// - ReadSorc(): Otettu käyttöön ja tyyppi muutettu SorceTypeksi.
// - Sorc: Otettu käyttöön ja tyyppi muutettu SorceTypeksi.
// - WriteEdka(): Tietojen luku muutettu vastaamaan uutta tietorakennetta.
// - Delete(): locationIndex otettu käyttöön.
// - ButtonClick(): arrayIndex ja JOHTO_LIITTYMA otettu käyttöön.
//
// 16    13.01.04 21:32 DEVELOPER2
// Reijolta 13.1.2004
//
// 15    11.01.04 16:42 DEVELOPER2
// Korjattu johto-osien nappien tekstit alkamaan ykkösestä:
// - GetConnectionCount(): Funktio lisätty liityntäosien lukumäärän tutkimiseen.
// - CreateJohto(): TJohto.Create()-funktion kutsu päivitetty vastaamaan
// muutoksia. GetConnectionCount() otettu käyttöön.
//
// 14    11.01.04 15:24 DEVELOPER2
// Reijolta 11.01.2004
//
// 13    10.01.04 13:16 DEVELOPER2
// Korjattu edeltävän verkon viimeisen johto-osan yksiköiden peittyminen:
// - GetTop():  GetHBorder funktio korvattu GridLineWidth metodilla
// - Resize():  Data paneelin kokoa ei pienennetä EDV_JOHTO_BORDER arvolla
// - NextLineTop(): GetHBorder funktio GridLineWidth metodilla
// - PrevLineTop(): GetHBorder funktio GridLineWidth metodilla
// - HeaderGridHighestRow(): SetGridHeight funktio GetMaxHeight metodilla
// - HeaderGridWidestCol(): SetGridWidth funktio GetMaxWidth metodilla
//
// 12    22.11.03 10:48 DEVELOPER2
// - Rinnakkaisliitynnän käsittely lisätty
// - Turhia paneeleja poistettu
// - Turhia käännöslippuja poistettu
// - FIRST_CABLE ja sen käsittely poistettu
//
// 11    9.11.03 15:22 DEVELOPER2
// Korjaus: Johto-osien johdot ja jakokeskukset korjattu piirtymään oikein, kun
// johto-osia listään, poistetaan tai ladataan.
//
// 10    9.11.03 14:07 DEVELOPER2
// Päivitykset Reijolta 3.11.2003
//
// 9     2.11.03 12:24 DEVELOPER2
// CableNola otettu käyttöön
//
//DEVELOPER1:n muutoksia, ks. kohta PohjaClick/DblClick, löytyy: etsi 'DEVELOPER1' (=aivan lopussa)

unit Johdot;

{$I ..\globals\defines.inc}

// Tässä tiedostossa tunnisteet 100000 - 100999

interface
uses
  { Omat unitit }
  Globals,    { Globaalit määritykset }
  Settings,   { Asetusolio }
  TextBase,   { Tekstivarasto }
  Defs,       { Yleiset asetukset }
  Johto,
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  StdCtrls, Grids, StringGridNola, LabelNola, PanelNola, NolaComp,
  ToolWin, ComCtrls, ExtCtrls, Buttons, PaaVal, Y_, LaskeeOd{+3.0.2};

type
 TJohdot = class(TObject)
    johdotList: TList;
    destroyList: TList;

    DefaultOpenButton, DefaultHideButton: TSpeedButton;
    dataWnd: TPanel;
    headerGrid: TStringGridNola;
    headerHeader: TPanel;
    headerPanel: TPanel;
    headerImage: TImage;
    headerColPanel: TPanel;
    dataPanel: TPanel;
    aFirstJohtoImage: TImage;
    dataJohto0Panel: TPanel;
    vscroll: TScrollBar;
    hscroll: TScrollBar;
    owner: TComponent;
    lastJohto: TJohto;

    procedure HeaderGridAfterPaint(Sender: TObject);
    procedure HeaderGridHighestRow(Sender: TObject; ACol, ARow: longint; newHeight: integer);
    procedure HeaderGridWidestCol(Sender: TObject; ACol, ARow: longint; newWidth: integer);

    procedure MouseMove(col,row: integer); //<+Col 12.0.0
    procedure Clean;

  private
    FEdka:      edkatype;
    FYLE:       EdvTiedotType;
    FSorc:      SorceType;
    FNjL:       EdvNjLahtoType;
    Click:      TNotifyEvent;
    lastHeaderImageWidth: integer;
    AvusteMove: Boolean;

  public
    constructor Create(AOwner: TComponent;
                       aHeaderPanel, AColHeaderPanel, ADataPanel: TPanel;
                       aHeaderHeaderPanel: TPanel;
                       aDataWnd: TPanel;
                       aVerticalScroll, aHorizontalScroll: TScrollBar;
                       aDefaultOpenButton, aDefaultHideButton: TSpeedButton);
    destructor Destroy; override;
    function   GetJohto(johto: integer): TJohto;
    procedure  CreateJohto(locationIndex, arrayIndex: integer; johtoType: TJohtoType);
    function   GetText(johto: integer; kohta: real): string;
    function   GetWidth:integer;
    function   GetHeight:integer;
    function   GetTop(arow: integer):integer;
    function   GetAbsoluteCount: integer;
    function   GetJohtoCount: integer;
    function   GetLast: TJohto;
    function   GetFirst: TJohto;
    procedure  SetTexts;
    procedure  Delete(johto: integer);
    procedure  GetBiggest(var aWidth, aHeight, aFromLeft, aHeaderHeight: integer);
    procedure  Resize;
    procedure  DrawGraphics;
    procedure  CheckScrollBars;
    function   NextJohtoLeft: integer;
    function   PrevJohtoLeft: integer;
    function   NextLineTop: integer;
    function   PrevLineTop: integer;

    // Function returns number of the connection before the first normal cable
    // return: number of the connections in the beginning of the network
    function  GetLiittymaCount(): integer;

    // Function returns number of the normal cables
    // return: number of the normal cables
    function  GetJohtoOsiaCount(): integer;

    procedure  ButtonClick(sender: TObject);
    procedure  PohjaClick(Sender: TObject);
    procedure  PohjaDblClick(Sender: TObject);
    procedure  HeaderClick(Sender: TObject);
    procedure  HeaderDblClick(Sender: TObject);

// DEVELOPER2 2005-08-29 BEGIN +8.0.0
    // Procedure updates the type of the cables
    procedure  UpdateJohtoTypes;
// DEVELOPER2 2005-08-29 END

    procedure WriteYLE(var value: EdvTiedotType);
    function  ReadYLE: EdvTiedotType;

    procedure WriteSorc(var value: SorceType);
    function  ReadSorc: SorceType;

    procedure WriteNjL(var value: EdvNjLahtotype);
    function  ReadNjL: EdvNjLahtotype;

    procedure WriteEdka(var value: edkatype);
    function  ReadEdka: edkatype;

    //property  YLE:       EdvTiedotType  read ReadYLE       write WriteYLE;
    //property  Sorc:      SorceType      read ReadSorc      write WriteSorc;
    //property  NjL:       EdvNjLahtoType read ReadNjL       write WriteNjL;
    //property  edka:      edkatype       read ReadEdka      write WriteEdka;

    procedure HeaderGridMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer);

    procedure HideHeader;
    procedure ShowHeader;

    //property   Johto[ajohto: Integer]: TJohto read GetJohto; default;

  published
//  property   Johto[ajohto: Integer]: TJohto read GetJohto; default; //< -DEVELOPER2 9.1.2000
    property   Width: integer          read GetWidth;
    property   Height: integer         read GetHeight;

  end;

implementation
uses
    Syotto, SyottoAv, EdvNew, EdvNewLask, progres, TextBaseTexts, NjVrk{NjVrk.Active takia}, DetEv{if Focused takia},
    Koe{KoeW_ 12.0.0};
VAR eRw :integer;      //<+120.5: Jotta StringGrid´in testauksessa fileenkirjoitusta voisi rajoittaa 1xRv per riviltään.

///////////////////////////////////////////////////////////////////////////////
constructor TJohdot.Create(AOwner: TComponent;
                           aHeaderPanel, AColHeaderPanel, ADataPanel: TPanel;
                           aHeaderHeaderPanel: TPanel;
                           aDataWnd: TPanel;
                           aVerticalScroll, aHorizontalScroll: TScrollBar;
                           aDefaultOpenButton, aDefaultHideButton: TSpeedButton);
begin
Tics ('TJohto.Create 1');
    // Tietoja ei ole asetettu
    eRw := 0;                               //<+120.5: HeaderGrid´in fileenkirjoituksen (yms.) rajoittukseen 1x per riviltä.
    DefaultOpenButton := aDefaultOpenButton;
    DefaultHideButton := aDefaultHideButton;
    dataWnd :=           aDataWnd;
    headerHeader :=      aHeaderHeaderPanel;
    headerPanel :=       aHeaderPanel;
    headerColPanel :=    aColHeaderPanel;
    dataPanel :=         aDataPanel;
    vscroll :=           aVerticalScroll;
    hscroll :=           aHorizontalScroll;
    owner :=             aowner;

    avusteMove :=        True;
    lastJohto :=         nil;
    lastHeaderImageWidth := -1;

    // HeaderGrid =Edvn RiviNimet vas. laidassa.
    headerGrid :=        TStringGridNola.Create(headerColPanel);
    headerGrid.Parent := headerColPanel;
    headerGrid.SelectionEnabled :=  False;
    headerGrid.DefaultCellAlign :=  alLeft;
    headerGrid.DefaultCellVAlign := alMiddle;
    headerGrid.Top :=               0;
    headerGrid.Left :=              0;
    headerGrid.rowCount :=          arvo_MAX_GRID_14 + 2 + 1 + rjohto_MAX_9 + nJohto_MAX_4 {+1{§§§}; //< -1  6.0.4
    headerGrid.colCount :=          EDV_HEADER_COLS_2 + 1;                                            //'MAX_GRID 9.0.1
    headerGrid.fixedRows :=         0;
    headerGrid.fixedCols :=         headerGrid.colCount - 1;
    headerGrid.OnAfterPaint :=      self.HeaderGridAfterPaint;
    headerGrid.OnHighestColInRow := HeaderGridHighestRow;
    headerGrid.OnWidestColInRow :=  HeaderGridWidestCol;
    headerGrid.align :=             alClient;
    headerGrid.ScrollBars :=        ssNone;
    headerGrid.BorderStyle :=       bsSingle;
    headerGrid.Visible :=           False;
    headerGrid.Options :=           [goFixedHorzLine, goFixedVertLine];
    headerGrid.FixedColor :=        clSilver;
    headerGrid.Ctl3D :=             False;
    headerGrid.OnMouseMove :=       HeaderGridMouseMove;
    headerGrid.OnClick :=           HeaderClick;
    headerGrid.OnDblClick :=        HeaderDblClick;

    HeaderImage :=                  TImage.Create(HeaderPanel);
    HeaderImage.Parent :=           HeaderPanel;
    HeaderImage.Transparent :=      True;
    HeaderImage.Width :=            EDV_MAX_IMAGE_WIDTH;
    HeaderImage.Height :=           EDV_BUTTON_HEIGHT;
    HeaderImage.Autosize :=         False;
    HeaderImage.Stretch :=          False;
    headerImage.OnClick :=          PohjaClick;
    headerImage.OnDblClick :=       PohjaDblClick;

    aFirstJohtoImage := TImage.Create(aHeaderHeaderPanel);
    aFirstJohtoImage.Parent :=      aHeaderHeaderPanel;
    aFirstJohtoImage.Transparent := True;
    aFirstJohtoImage.Width :=       EDV_JOHTO_BORDER;
    aFirstJohtoImage.align :=       alRight;
    aFirstJohtoImage.Height :=      500; // Tämä täytyy olla suuri, koska sitä ei voi enää muuttaa myöhemmin
    aFirstJohtoImage.Autosize :=    False;
    aFirstJohtoImage.Stretch :=     False;

    johdotList := TList.Create;
    johdotList.Clear;

    destroyList := TList.Create;
    destroyList.Clear;

    SetTexts;
    headerGrid.Visible :=          {false;//}True; //12.0.0 ååå FA paljastaa: HeaderGrid on RiviNimiGrid edvn vas.laidassa.
//headerGrid.Color := clAqua;                      //12.0.0 ååå Tällä ei vaikutusta.
    click := ButtonClick;
Tics ('TJohto.Create 9');
end;

///////////////////////////////////////////////////////////////////////////////
destructor TJohdot.Destroy;
var
   x, count: integer;
begin
     count := johdotList.count;

     for x:= 0 to count - 1 do
         Delete(x);

     JohdotList.Destroy;

     Clean;

     Inherited;
end;

///////////////////////////////////////////////////////////////////////////////
function   TJohdot.GetJohto(johto: integer): TJohto;
begin
     if JohdotList.count > johto  then
        Result := JohdotList[johto]
     else
         Result := nil;
end;

///////////////////////////////////////////////////////////////////////////////
procedure  TJohdot.Clean;
var
   count,x: integer;
begin
     // Tuhotaan tuhoamatta jääneet
     count := destroyList.count;
     for x:= 0 to count - 1 do
     begin
         TJohto(destroyList[x]).Destroy;
     end;

     destroyList.Clear;
end;

///////////////////////////////////////////////////////////////////////////////
procedure  TJohdot.CreateJohto(locationIndex, arrayIndex: integer; johtoType: TJohtoType);
var
   johdotTop: integer;
   left, width, height, fromLeft, headerHeight: integer;
begin
Tics ('TJohto.CreateJohto 1');
     Clean;

     JohdotTop := GetTop(arvo_MAX_GRID_14 + 2 + 1);                                    //<MAX_GRID 9.0.1

     if JohdotList.count <= locationIndex then
        JohdotList.count := locationIndex + 1;

     // Siirretään viimeinen johto-osuus viimeiseksi ja uusi toiseksi viimeiseksi
     if ((johtoType = JOHTO_NORMAL) or (johtoType = JOHTO_LIITTYMA)) and
         (JohdotList[locationIndex] = lastJohto) then
     begin
          lastJohto.locationIndex := locationIndex + 1;
          JohdotList.count := lastJohto.locationIndex + 1;
          JohdotList[lastJohto.locationIndex] := lastJohto;
          JohdotList[locationIndex] := nil;
          lastjohto.refresh;
     end;

     GetBiggest(width, height, fromLeft, headerHeight);
     height := height +200; //§§§

     left := DataPanel.Width;

     JohdotList[locationIndex] := TJohto.Create(self, locationIndex, arrayIndex, johtoType,
                                           headerPanel, dataPanel,
                                           left,width,height,fromLeft, headerHeight,
                                           johdotTop,
                                           DefaultOpenButton, DefaultHideButton);
     case JohtoType of
     JOHTO_LAST:
              begin
                lastJohto :=      JohdotList[locationIndex];
                lastJohto.WriteNjL(FNjL);
              end;
     JOHTO_NORMAL:
              begin
                // Ei tehdä mitään
              end;
     JOHTO_LIITTYMA:
              begin
                //,,,,,,... Tällä saadaan rinnakkaisliittymä testimielessä.
                GetJohto(locationIndex).WriteYLE(FYLE);
              end;
     end;

Tics ('TJohto.CreateJohto 9');
end;

// DEVELOPER2 2005-08-29 BEGIN +8.0.0
///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.UpdateJohtoTypes();
var
   johtoIndex: integer;
   johto: TJohto;
   johtoNormaaliLkm: integer;
   johtoLiittymaLkm: integer;
   johtoKokonaisLkm: integer;
   isChanged: boolean;
begin
Tics ('TJohto.UpdateJohtoTypes 1');
     johtoNormaaliLkm := GetJohtoOsiaCount;
     johtoLiittymaLkm := GetLiittymaCount;
     johtoKokonaisLkm := johtoNormaaliLkm + johtoLiittymaLkm;

     for johtoIndex := 0 to johtoLiittymaLkm - 1 do
     begin
          isChanged := false;
          johto := GetJohto(johtoIndex);
          isChanged := isChanged or johto.SetType(JOHTO_LIITTYMA);
          isChanged := isChanged or johto.SetArrayIndex(johtoIndex + 1);

          if (isChanged) then
               johto.ReFresh;
     end;

     for johtoIndex := johtoLiittymaLkm to johtoKokonaisLkm - 1 do
     begin
          isChanged := false;
          johto := GetJohto(johtoIndex);
          isChanged := isChanged or johto.SetType(JOHTO_NORMAL);
          isChanged := isChanged or johto.SetArrayIndex(johtoIndex + 1);

          if (isChanged) then
               johto.ReFresh;
     end;
Tics ('TJohto.UpdateJohtoTypes 9');
end;//UpdateJohtoTypes
// DEVELOPER2 2005-08-29 END

///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.WriteYLE(var value: EdvTiedotType);
var
   last: integer;      s :string;         //s     :DEVELOPER1
   uusia: integer;     GotCount :integer; //GotC..:DEVELOPER1
   kohta: integer;     korj     :integer; //korj  :DEVELOPER1
   johtoNormaaliLkm: integer;
   johtoLiittymaLkm: integer;
   johtoKokonaisLkm: integer;
begin
Tics ('TJohto.WriteYLE 1');
     FYLE := value;                         //< @:1   Ei ohjaudu.
     kohta := 0;
     johtoNormaaliLkm := GetJohtoOsiaCount;
     johtoLiittymaLkm := GetLiittymaCount;
     johtoKokonaisLkm := johtoNormaaliLkm + johtoLiittymaLkm;

     uusia := johtoKokonaisLkm - GetJohtoCount;
     GotCount := GetJohtoCount;                          //<BreakPointille :DEVELOPER1. NYT KÄYTETÄÄN MYÖS
     korj := 0;                                          //'IF GotCount=0 THEN PaaValFrm.REFRESH, ks.lopussa
     if GotCount>0  then korj := 1;            //<Muuten ProgrsBar jää 1x jälkeen, ks. ASETA+ESITAprogres
     s := '';   if korj>0  then s := IntToStr(korj);

     if (uusia < 0) then                                      //<Muutettaessa Edv :oa
     begin
          uusia := Abs(uusia);
          asetaProgres(myTextBase.Get(JOHDOT_LISAA_JOHTOJA), uusia+korj);
{11}      esitaProgres(myTextBase.Get(JOHDOT_JOHDOT) + ' (1 .. '+IntToStr(GotCount)+') :  '+s, korj);
     end
     else
     if (uusia > 0) then                                      //<Alkulataus = '0...'
     begin
          asetaProgres(myTextBase.Get(JOHDOT_POISTA_JOHTOJA), uusia+korj);
{12}      esitaProgres(myTextBase.Get(JOHDOT_JOHDOT) +' ('+IntToStr(GotCount)+' .. '+IntToStr(GotCount+uusia)+') :  '+s, korj);
     end;

     if (lastJohto = nil) then
     begin
        CreateJohto(0, johtoNormaaliLkm + 1, JOHTO_LAST);     // arrayIndex alkaa 1:stä
     end;

     // Johto-osien lukumäärä
     if johtoKokonaisLkm > GetJohtoCount then
     begin
          last := GetJohtoCount;
          while (johtoKokonaisLkm > GetJohtoCount) do
          begin
               kohta := kohta + 1;
               s := '';   if kohta+korj>1  then s := ',';

               if (kohta < uusia) then
{21}              esitaProgres(s +IntToStr(kohta+korj), kohta+korj)
               else
{22}              esitaProgres(s +IntToStr(kohta+korj), kohta+korj);               //<Vika Nro tästä

               if (last < johtoLiittymaLkm) then
                  CreateJohto(last, last + 1, JOHTO_LIITTYMA)                      // arrayIndex alkaa 1:stä
               else
                  CreateJohto(last, last + 1 - johtoLiittymaLkm, JOHTO_NORMAL);    // arrayIndex alkaa 1:stä
               last := last + 1;
          end;
     end
     else if johtoKokonaisLkm < GetJohtoCount then
     begin
          // Tuhotaan vain normaaleja johtoja ja jätetään JOHTO_LAST
          // jäljelle, joten aloitetaan tuhoaminen GetJohtoCount - 1
          // eikä GetJohtoCount
          last := GetJohtoCount - 1;

          while (johtoKokonaisLkm < GetJohtoCount) do
          begin
               kohta := kohta + 1;
               s := '';   if kohta+korj>1  then s := ',';

               if (kohta < abs(uusia)) then
{31}              esitaProgres(s +IntToStr(kohta+korj), kohta+korj)
               else
{32}              esitaProgres(s +IntToStr(kohta+korj), kohta+korj);               //<Vika Nro tästä

               Delete(last);
               last := last - 1;
          end;
     end;

// DEVELOPER2 2005-08-29 BEGIN +8.0.0
     // Käydään läpi johdot ja merkitään minkä tyyppinen mikin johto-osa on.
     // Johto-osan tyypiksi voi jäädä esim. JOHTO_NORMAL vaikka johto onkin
     // liittymä.
     UpdateJohtoTypes();
// DEVELOPER2 2005-08-29 END

     if (lastJohto <> nil) then
        lastJohto.refresh;

     if (uusia <> 0) then
        esitaProgres('', uusia);

{    if (EdvNewFrm.Visible) then //<,,DEVELOPER1 23.10.00  Error:  Cannot focus disabled or invisible ...
     begin                       //'  (kun tehtiin uutta johto-osaa = "Lisää"-btn). Siirretty EdvNew.PAS:iin
          EdvNewFrm.Show;      //<Tultaessa PaaValista, eioo vielä näkyvissää =muuten error, TODETTU
          EdvNewFrm.SetFocus;  //<Muuten Progrs.Hide jälkeen focus palaa PaaValiin=TULEE PÄÄLLE, TODETTU
     end;//}

     //progresFrm.Hide;
     ProgresFrm.Close;
    if GotCount=0  then PaaValFrm.refresh; //<If -ehto =DEVELOPER1:  Jottei ProgrsBarin jälki jää NjBtn päälle !!!
Tics ('TJohto.WriteYLE 9');
end;//WriteYLE

///////////////////////////////////////////////////////////////////////////////
function TJohdot.ReadYLE: EdvTiedotType;
begin
     result := FYLE;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.WriteNjL(var value: EdvNjLahtotype);
begin
     FNjL := value;

     if (lastJohto <> nil) then
        lastJohto.WriteNjL(value);
end;

///////////////////////////////////////////////////////////////////////////////
function  TJohdot.ReadNjL: EdvNjLahtotype;
begin
     if (lastJohto <> nil) then
        result := lastJohto.ReadNjL()
     else
         result := FNjL;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.WriteSorc(var value: SorceType);
var
   x, {johtoNormaaliLkm, }johtoLiittymaLkm: integer; //<.. Never used
begin
Tics ('TJohto.WriteSorc 1-1');
  //johtoNormaaliLkm := GetJohtoOsiaCount;           //<.. Never used
    johtoLiittymaLkm := GetLiittymaCount;

    FSorc := value;
    for x := 0 to johtoLiittymaLkm - 1 do
    begin
         GetJohto(x).WriteSrc(value[x + 1].src);            // Taulukko alkaa 1 -> + 1
         GetJohto(x).WriteEdvJohto(value[x + 1].josa);
        {if (self[x].EdvJohto.Nimi.arvoStr='111') or                          //<,+8.0.8
            (self[x].EdvJohto.Nimi.arvoStr = value[x + 1].josa.Nimi.arvoStr)
            then beep;}
    end;
end;

///////////////////////////////////////////////////////////////////////////////
function  TJohdot.ReadSorc: SorceType;
begin
  result := FSorc;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.WriteEdka(var value: edkatype); //edv.edka[]
var
   x,gj,johtoLiittymaLkm: integer;
begin
Tics ('TJohto.WriteEdka 1-1');
  //johtoNormaaliLkm := GetJohtoOsiaCount; //<.. Never used
    johtoLiittymaLkm := GetLiittymaCount;
    gj := self.GetJohtoCount;              //<KunSorja=5 ja Edja=20  => gj=25 =Max.  GJ avuksi 8.0.6

    FEdka := value;                        //AsTapa§ AsTapDeb§  @:2  Ei ohjaudu.
    for x := johtoLiittymaLkm to gj{self.GetJohtoCount} - 1 do
    begin                                                     //,@ EiOhjaudu
         GetJohto(x).WriteEdvJohto(value[x - johtoLiittymaLkm + 1]); //Taulukko alkaa 1 -> + 1 //> IsEqual...
    end;
end;

///////////////////////////////////////////////////////////////////////////////
function  TJohdot.ReadEdka: edkatype;
begin
    result := FEdka;
end;

///////////////////////////////////////////////////////////////////////////////
function  TJohdot.GetWidth:integer;
begin
     result := DataPanel.Width;
end;

///////////////////////////////////////////////////////////////////////////////
function  TJohdot.GetTop(arow: integer):integer;
var
   border: integer;
   x: integer;
   height: integer;
begin
     height := 0;

     border := headerGrid.GridLineWidth;

     for x:= 0 to arow - 1 do
         if (x < HeaderGrid.rowCount) then
            height := height + HeaderGrid.rowHeights[x] + border;

     Result := headerGrid.Top + height;
end;

///////////////////////////////////////////////////////////////////////////////
function  TJohdot.GetHeight:integer;
begin
     result := DataPanel.Height;
end;

///////////////////////////////////////////////////////////////////////////////
function  TJohdot.GetText(johto: integer; kohta: real): string;
begin
     // Result := johtoGrid.Cells[GetCol(johto, kohta), GetRow(kohta)];
end;

///////////////////////////////////////////////////////////////////////////////
function  TJohdot.GetAbsoluteCount: integer;
begin
     if JohdotList <> nil then
        result := JohdotList.Count
     else
         result := 0;
end;

///////////////////////////////////////////////////////////////////////////////
function  TJohdot.GetJohtoCount: integer;
var
   count: integer;
begin
     if JohdotList <> nil then
     begin
        count := GetAbsoluteCount;
        if lastJohto <> nil then count := count - 1;
        result := count;
     end
     else
         result := 0;
end;

///////////////////////////////////////////////////////////////////////////////
function   TJohdot.GetLast: TJohto;
begin
     if johdotList.count > 0 then
        result := TJohto(johdotList.last)
     else
         result := nil;
end;

///////////////////////////////////////////////////////////////////////////////
procedure   TJohdot.Delete(johto: integer);
var
   x, arrayIndex: integer;
begin
     if johdotList.count > johto then
     begin
          if ( johdotList[johto] = lastJohto) then
             lastJohto := nil;

          if (johdotList[johto] <> nil) then
          begin
             TJohto(johdotList[johto]).Hide;
             destroyList.Add(johdotList[johto]);
          end;

          // Tallennetaan arrayIndex, jotta poistettavan johdon jälkeisten
          // johtojen indeksit voitaisiin päivittää kuntoon
          arrayIndex := TJohto(johdotList[johto]).arrayIndex;

          johdotList.Delete(johto);

          // Laitetaan indexit kuntoon
          if (lastJohto <> nil)  then
          begin
             lastJohto.locationIndex := lastJohto.locationIndex - 1;
             lastJohto.refresh;
          end;

          for x:= johto to johdotList.count - 1 do
          begin
            if (johdotList[x] <> nil) then begin
                TJohto(johdotList[x]).locationIndex := x;
                TJohto(johdotList[x]).arrayIndex := arrayIndex;
                arrayIndex := arrayIndex + 1;
            end;
          end;
     end;
end;//Delete

///////////////////////////////////////////////////////////////////////////////
function   TJohdot.GetFirst: TJohto;
begin
     if johdotList.count > 0 then
        result := TJohto(johdotList.last)
     else
         result := nil;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.Resize;
var
   x: integer;
   johto: TJohto;
   width:  integer;
   height: integer;
   headerHeight: integer;
   left: integer;
   johdotTop: integer;
   fromLeft: integer;
begin
Tics ('TJohto.Resize 1');
     HeaderColPanel.Width := HeaderGrid.Width;
     HeaderColPanel.Height:= HeaderGrid.Height;
     HeaderColPanel.refresh;
     left := 0;
     GetBiggest(width, height, fromleft, headerHeight);
     JohdotTop := GetTop(arvo_MAX_GRID_14 + 2 + 1);                                    //<MAX_GRID 9.0.1

     HeaderPanel.Height:= HeaderHeight;
     HeaderPanel.refresh;

     DataPanel.Height :=  height;
     DataPanel.refresh;

     HeaderImage.Top := HeaderPanel.Height - EDV_BUTTON_HEIGHT;

     for x := 0 to GetAbsoluteCount - 1 do
     begin
          johto := GetJohto(x);

          if Johto <> nil then
          begin
               if (johto = lastJohto) then
                   johto.ReSize(left, johto.realwidth, height, fromLeft, JohdotTop, headerHeight)
               else
                   Johto.ReSize(left, width, height, fromLeft, JohdotTop, headerHeight);

               left := left + johto.width;
          end;
     end;

     HeaderPanel.width := left;
     HeaderPanel.Refresh;
     DataPanel.Width :=   left;
     DataPanel.Refresh;

     DrawGraphics;

     CheckScrollBars;
Tics ('TJohto.Resize 9');
end;//Resize

///////////////////////////////////////////////////////////////////////////////
procedure  TJohdot.DrawGraphics;
var
   cableFromHeaderBottom: integer;
   Kind :integer;
begin
Tics ('TJohto.DrawGraphics 1');
    // Piirretään Johto
    if (GetJohto(0) <> nil) then
    begin
       // Header Image on johto osien välistä näkyvä kaapeli.
       cableFromHeaderBottom := HeaderImage.height - (headerPanel.Height - GetJohto(0).CablePos);

//,,,TÄSSÄ MÄÄRÄTÄÄN 1. LIITTYMÄN SYMBOLIn INDEXI: sj/pj/gener/ups. Valinta "toistuu" PRC DrawLiittymaOsa :ssa,,,
// Ensimmäinen rinnakkaisliittymäjohto, 2. ks. TJohto.DrawGraphics.   Kind: 1=Transformer  2=LV-Cable  3=Generator  4=UPS
       Kind := a_getIntg (10011, edv.Sorc[1].Src.SorceKind);  //< OK, AINA KIINTEÄ OSOIUS [1], koska vain 1.TÄSSÄ.
       DrawLiittymaOsa(aFirstJohtoImage, GetJohto(0).CablePos, false, Kind{2}); //< 2= ALP kolvattu PJ-liittymä
    end                                 //'SorceKind:  1=Transformer  2=LV-Cable  3=Generator  4=UPS
    else
       cableFromHeaderBottom := EDV_BUTTON_HEIGHT div 2;
    DrawJohto(HeaderImage, JOHTO_NORMAL, cableFromHeaderBottom);
Tics ('TJohto.DrawGraphics 9');
end;

///////////////////////////////////////////////////////////////////////////////
procedure  TJohdot.CheckScrollBars;
var
   mywidth, myheight, FromLeft, HEaderHeight, totalWidth: integer;
   lastWidth: integer;
   last: TJohto;
begin
     GetBiggest(myWidth, myHeight, fromLeft, HeaderHeight);
     myHeight := height;
     totalWidth := width;

     VScroll.Min :=        0;

     if (myHeight - DataWnd.Height > VScroll.Min) then
        VScroll.Max :=     myHeight - DataWnd.Height
     else
         if DataPanel.Top < 0 then
         begin
            VScroll.Min := DataPanel.Top;
            VScroll.Max := 0;
         end
         else
           VScroll.Max :=   HScroll.Min;

     VScroll.LargeChange := HeaderGrid.RowHeights[HeaderGrid.TopRow] +
                            HeaderGrid.GridLineWidth;
     VScroll.SmallChange := VScroll.LargeChange;

     if (dataPanel.Top >= 0) and
        (dataPanel.Top + dataPanel.Height <= dataWnd.Height) then
        VScroll.Visible := False
     else
        VScroll.Visible := True;

     HScroll.Min :=        0;

     last := GetLast;

     if last = nil then
     begin
        lastWidth := myWidth;
     end
     else
     begin
        lastWidth := last.Width;
     end;

     if totalWidth - lastWidth  > HScroll.Min then
        HScroll.Max :=     totalWidth - lastwidth
     else
        HScroll.Max :=     HScroll.Min;

     if (dataPanel.Left >= 0) and
        (dataPanel.Left + dataPanel.Width <= dataWnd.Width) then
        HScroll.Visible := False
     else
        HScroll.Visible := True;

     HScroll.LargeChange := myWidth + EDV_JOHTO_BORDER;
     HScroll.SmallChange := HScroll.LargeChange;
end;//CheckScrollBars

///////////////////////////////////////////////////////////////////////////////
procedure  TJohdot.GetBiggest(var aWidth, aHeight,aFromLeft, aHeaderHeight: integer);
var                           //DEVELOPER1:  Tässä asetetaan/säädetään kaikkien johto-osien palstojen leveydet samoiksi.
   johto: TJohto;             //       Hakusanoja:  Palstalev Palstalveys Palstalveydet  aseta  asettaa  määrää +10.0.4u
   x: integer;
begin
      aWidth :=        0;
      aHeight :=       0;
      aHeaderHeight := 0;
      aFromLeft :=     0;
                      {x := GetAbsoluteCount; //+9.0.1
                       if x>-1  then ;}
      for x:= 0 to GetAbsoluteCount - 1 do
      begin
          johto := GetJohto(x);
          if (johto <> nil) then
          begin
               if (johto.RealWidth > aWidth) then
                  aWidth := johto.RealWidth;        //<DEVELOPER1:  200 liian kapea, jättää rv 32..35 hännät vex. +9.0.1
               if (johto.RealHeight > aHeight) then //'-120.3e :-100
                  aHeight := johto.RealHeight;
               if (johto.RealHeaderHeight > aHeaderHeight) then
                  aHeaderHeight := johto.RealHeaderHeight;
               if (johto.RealFromLeft > aFromLeft) then
                  aFromLeft := johto.RealFromLeft;
          end;
      end;
end;//GetBiggest

///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.SetTexts; //Vas PÄÄPANELIN TEKSTIT, esim:  Ik3th (Kilpiarvo Icw 1s)
var
   text,tmp,color :string;
   x,u,ai,ii :integer;
   johto  :TJohto;

   procedure  wr(si :string);      begin end; {VAR f :TextFile;  fn :string;      begin //Erinomainen.
   //fn := '\\VERKKOLEVY\Nola\__projE\Projektit XE2\NolaKehi\BIN\SetTx.txt';
   fn := gAjoPath +'SetTx.txt'; //+130.0
      AssignFile(f,fn);
      if fFileExists (fn)
         then Append(f)
         else Rewrite(f);
      Writeln(f,si);                                         //'Kirjjoitetaan jakoviiva ja aikaleima jos aikaeroa >=4s.
      Flush(f);
      Close(f);
   end;//}
   function etuM(si :string;  ii :integer) :string;     begin//<Alkumrk +Tekee lisäOhjausNroista str.
      {result := si +Ints(ii) +'  ';  }end;
   function etuS(ii :integer) :string;     begin             //<Tekee lisäOhjausNroista str.
     {result := '¤' +Ints(ii) +'  ';  }end;
                                                                                                    //case Indx of        PrRjMm2Bx´n PudValikon itemit:
begin//SetTexts...........................                                                          //   0 = '16A 2.5/10A 1.5 mm²'; <= Sul,Mm2
Tics ('TJohto.SetTexts 1');                         //,30 koska ..Count´ssa on erikoisia          //   1 = '10A 2.5/1.5 mm²';        - " -
   {headerGrid.Color := clAqua;                                                                     //   2 = '6A  2.5/1.5 mm²';        - " -
    headerGrid.Font.Color := clAqua;                  //<Vain (ofa(Ik3th/d) Aquaksi, muu teksi mustana.
    HeaderPanel.Color := clAqua;                                                              //,,###########################################################
  //headerGrid.Visible := false;     //<Tällä häviää riviselitysten paneli (eka vasemmalla).} //,,RivinimitysPANEELIN riviNIMET #############################
                                                                                              //,,###########################################################
    for x := 0 to {headerGrid.rowCount - } {42}33  do // hypyllä ohjattavia 120.5 .                 //   3 = '4A  2.5/1.5 mm²';        - " -
    begin //u := 0;                                   //<U näyttää mistä kuljettu debugissa.        //   4 = '2A  2.5/1.5 mm²';        - " -
        color := EDV_COLOR_FONT_HEADER;                                                             //   5 = '4 mm² 16A/10A';          Mm2,Sul
//Color := COLOR_WHITE;                                                                             //   6 = '6 mm² 16A/10A';ta
      //ai := 0;                                      //<+Siirtty 1412.                             //   7 = '10 mm² 16A/10A';
        if (x+1) IN [18..25]                          //< 18^=rv23.. 25^=30.                        //   8 = '16 mm² 16A/10A';  end;
        then begin  u := 1;                       //text := Ints(x+1);
           case PrRjIndx of //0..8                //,,Eihän näihin mennä kuin x+1=18..25                      ,0 = '16A 2.5/10A 1.5 mm²'; <= Sul,Mm2
              0 :text := etuS(x+1) +myTextBase.Get(EDV_HEADERS + '-row-'+ Ints(x+1 +2));          //<-row-20  ,,x+1= 18..25
              1 :text := etuS(x+1) +myTextBase.Get(EDV_HEADERS + '-row-'+ Ints(x+1 +2 +10));      //<-row-30  1 = '10A 2.5/1.5 mm²';        - " -
              2 :text := etuS(x+1) +myTextBase.Get(EDV_HEADERS + '-row-'+ Ints(x+1 +2 +20));      //<-row-40  2 = '6A  2.5/1.5 mm²';        - " -
              3 :text := etuS(x+1) +myTextBase.Get(EDV_HEADERS + '-row-'+ Ints(x+1 +2 +30));      //<-row-50  3 = '4A  2.5/1.5 mm²';        - " -
              4 :text := etuS(x+1) +myTextBase.Get(EDV_HEADERS + '-row-'+ Ints(x+1 +2 +40));      //<-row-60  4 = '2A  2.5/1.5 mm²';        - " -
              5 :if x+1=18  then                                                                            //5 = '4 mm² 16A/10A';          Mm2,Sul
                 text := etuS(x+1) +myTextBase.Get(EDV_HEADERS + '-row-70')  else                 //<-row-70
                 if x+1=22  then
                 text := etuS(x+1) +myTextBase.Get(EDV_HEADERS + '-row-71');                      //<-row-71
              6 :if x+1=18  then                                                                            //6 = '6 mm² 16A/10A';ta
                 text := etuS(x+1) +myTextBase.Get(EDV_HEADERS + '-row-72')  else                 //<-row-72
                 if x+1=22  then
                 text := etuS(x+1) +myTextBase.Get(EDV_HEADERS + '-row-73');                      //<-row-73
              7 :if x+1=18  then                                                                            //7 = '10 mm² 16A/10A';
                 text := etuS(x+1) +myTextBase.Get(EDV_HEADERS + '-row-74')  else                 //<-row-74
                 if x+1=22  then
                 text := etuS(x+1) +myTextBase.Get(EDV_HEADERS + '-row-75');                      //<-row-75
              8 :if x+1=18  then                                                                            //8 = '16 mm² 16A/10A';
                 text := etuS(x+1) +myTextBase.Get(EDV_HEADERS + '-row-76')  else                 //<-row-76
                 if x+1=22  then
                 text := etuS(x+1) +myTextBase.Get(EDV_HEADERS + '-row-77');                      //<-row-77
           end;
           if (PrRjIndx IN [5..8])  then begin
              if (x+1) IN [19..21,23..25]   then BEGIN
                 text := etuS(x+1) +myTextBase.Get(EDV_HEADERS + '-row-'+ Ints(x+1 +2 +60));      //<-row-80..82, 85..87
                 u := 2;  end;
           end;
       end//''if (x+1) IN [18..25]
       else begin                 //<,,Tänne siis alkurvt row-1...-17 ja loppurvt row-31...-35  sekä row-90...94
           ai := 0;               //<1412: Siirtty alkuun.
           if x+1>25
              then ai := 64;      //<Tässä NYT mukana +2, koska alkurvt row-1...row-17 ilman +2´ta.  row-90...94
           ii := x+1+ai;          //,etuM ei nyt tee mitään.                                      //<Text= "Max.Lähdöt.." x=16 ii=17
           text := etuM('#',x+1) +myTextBase.Get(EDV_HEADERS + '-row-'+ Ints({x+1 +ai)}ii));      //<Text= "Ik1v" row-1..18, .90..Nousujohdot row-jne.
         //if ii=90  then text := text +EdvNewFrm.LaakMBx.Text +' kVA';
           if Pos('LÄÄKINTÄ-IT',AnsiUpperCase(text)) >0  then                                    //< x=25 ii=90
              text := text +fRmrkt0(Edv.YLE.LaakPmu.ArvoRea,1,1) +'/7,5kVA '; //<'+130.2e:  LääkMuuntaja 2 kokoa, 1. valittu LaakMBx.Text´ssa ja 2´na
           u := 3;                                                            //            lasketaan /7,5 kVA´n arvoilla.
         //wr('"""x=' +IntToStr(x)+' ai=' +IntToStr(ai)+'  u=' +Ints(u)+' x+1=' +Ints(x+1)+' => Text= ' +text); //<Hirmu hyvä/havainnollinen, kertoo kaiken: u,ai,x, Text.
       end;
       if u=0  then ;

        {$IFDEF arvot_oikealle}
        if x IN [0,15]  then                                                    //<Oli:  (x = 0) or (x = 15)
           tmp := color + text + ALIGN_RIGHT + myTextBase.Get( SYMBOLI_OIKEALLE)
        else if x IN [1,2,3,9]  then                                            //Oli:  (x=1) or (x=2) or (x=3) or (x=9) then
           tmp := color + myTextBase.Get(SYMBOLI_VASEMMALLE) + text
        else
        {$ENDIF}
        if x=25
           then tmp := OtsRv31_txt  //<+130.2e: Koska SetText onaa vain OnCreate´ssa, tämäTxtRv OTS´ssa EI PVITY LaakMBx´n mukaan, sille pvitettävä Johto.PAS´ssa.
           else tmp := color +text; //<TÄMÄ KAIKILLE MUILLE RIVEILLE #######################################################################################

//wr('x=' +IntToStr(x)+' ai=' +IntToStr(ai)+'  u=' +Ints(u)+' x+1=' +Ints(x+1)+' => Text= ' +text); //<Hirmu hyvä/havainnollinen, kertoo kaiken: u,ai,x, Text.
        SetText(headerGrid, 1 , x, tmp);                  //<TÄMÄ KAIKILLE RIVEILLE ########################################################################
//if x=25  then EdvNewFrm.KuvausEdit.Text := tmp;  //<KESKEN KESKEN:    EDV_COLOR_FONT_HEADER +Edv-pitka +'-row-' +Ints(90{ii})  Ei onaa näillä samaksi.
//<f n="" s="" c="16711680">Lääkintä-IT <right>jkC16 0,4s  3,5/7,5kVA
        if u=0 then ;
    end;//for x ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
wr('Ruudulla näkyy:__________________________________');  //<+130.0
    for x := 0 to headerGrid.RowCount - 1 do begin//<,,Rivien numerointi, Vas.reunan paneli.  [1,x] x=16 ="Max.Lähdöt/ Pituudet" -otsikko.
       headerGrid.Cells[0, x] := '<center> ' + EDV_COLOR_FONT_HEADER + STYLE_BOLD_BEGIN +intToStr(x+6)+' ';
       wr(headerGrid.Cells[1, x]);  end; //<+130.0

    for x := 0 to GetAbsoluteCount - 1 do
    begin
       johto := GetJohto(x);
       if (johto <> nil) then
          johto.SetTexts;
    end;
Tics ('TJohto.SetTexts 9');
end;//SetTexts
///////////////////////////////////////////////////////////////////////////////
function   TJohdot.NextJohtoLeft: integer;
var
   x: integer;
   left: integer;
   johto: TJohto;
begin
     left:= 0;
     x:= 0;

    while (left <= -(DataPanel.Left)) and (x < GetAbsoluteCount) do
     begin
          johto := GetJohto(x);

          if (johto <> nil) then
          begin
               left := johto.left;
          end;
          x := x + 1;
     end;

     Result := left;
end;

///////////////////////////////////////////////////////////////////////////////
function   TJohdot.PrevJohtoLeft: integer;
var
   x: integer;
   prevLeft, left: integer;
   johto: TJohto;
begin
    prevLeft := 0;
    left:= 0;
    x:= 0;

    while (left < -(DataPanel.Left)) and (x < GetAbsoluteCount) do
     begin
          prevLeft := left;

          johto := GetJohto(x);

          if (johto <> nil) then
          begin
               left := johto.left;
          end;
          x := x + 1;
     end;

     Result := prevLeft;
end;

///////////////////////////////////////////////////////////////////////////////
function   TJohdot.NextLineTop: integer;
var
   x: integer;
   top: integer;
   border: integer;
begin
    x:= 0;

    border := HeaderGrid.GridLineWidth;
    top :=    -border;

    while (top <= -(HeaderColPanel.Top)) and (x < HeaderGrid.RowCount) do
     begin
          top := top + HeaderGrid.RowHeights[x] + HeaderGrid.GridLineWidth;
          x := x + 1;
     end;

     Result := top;
end;

function   TJohdot.PrevLineTop: integer;
var
   x: integer;
   prevTop, top, border: integer;
begin
    prevTop := 0;
    top:= 0;
    x:= 0;

    border := HeaderGrid.GridLineWidth;

    while (top < -(HeaderColPanel.Top)) and (x < HeaderGrid.RowCount) do
     begin
          prevTop := Top;

          top := top + HeaderGrid.RowHeights[x] + border;
          x := x + 1;
     end;

     Result := prevTop;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.HideHeader;
begin
end;

///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.ShowHeader;
begin
end;

{ Komponenttien event-handlerit }
///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.HeaderGridAfterPaint(Sender: TObject);
var
   width: integer;
   border: integer;
   x: integer;
begin
     width := 0;
     border := 0;

     for x:=0 to HeaderGrid.ColCount - 2 do
         width := width + headergrid.ColWidths[x] + HeaderGrid.GridLineWidth + border;

     if HeaderColPanel.width <> width then
     begin
        HeaderColPanel.width := width;
        HeaderColPanel.refresh;
     end;

     width := 0;
     border := 0;

     for x := 0 to HeaderGrid.rowCount - 1 do
         width := width + HeaderGrid.RowHeights[x] + HeaderGrid.GridLineWidth + border;

     if HeaderColPanel.height <> width then
     begin
        HeaderColPanel.Height := width;
        HeaderColPanel.refresh;
     end;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.HeaderGridHighestRow(Sender: TObject; ACol, ARow: longint; newHeight: integer);
begin
     HeaderGrid.RowHeights[ARow] := newHeight;
     HeaderGrid.Height := HeaderGrid.GetMaxHeight;
     HeaderGrid.refresh;
end;

///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.HeaderGridWidestCol(Sender: TObject; ACol, ARow: longint; newWidth: integer);
begin
     HeaderGrid.ColWidths[ACol] := newWidth;
     HeaderGrid.Width := HeaderGrid.GetMaxWidth;
     HeaderGrid.refresh;
end;

///////////////////////////////////////////////////////////////////////////////
function  TJohdot.GetJohtoOsiaCount(): integer;
begin
  result := a_getIntg(100000, ReadYLE().JohtoOsia);
end;

///////////////////////////////////////////////////////////////////////////////
function  TJohdot.GetLiittymaCount(): integer;
begin
  result := a_getIntg(100001, ReadYLE().SorceCount);
end;

///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.ButtonClick(sender: TObject); //Johto-osan NoBtnClick JohtoBtn JBtn
var
   tmpJohto: TJohto;   os :integer;
begin
  tmpJohto := TJohto(TButton(sender).tag);
  os := tmpJohto.arrayIndex;                 //<DEVELOPER1 6.2.2
  tmpJohto.open := TRUE;

{JFileen('');  }JFileen('>EdvJ BtnClik:');
if IsDebuggerPresent  then SyottoAvFrm.Hide; //+120.6 Jottei avuste jää debuggauskulun tielle.

  case tmpJohto.JohtoType of                 //<,,DEVELOPER1 6.2.2
       JOHTO_LIITTYMA,JOHTO_NORMAL
                      :begin;
                          if tmpJohto.johtoType=JOHTO_LIITTYMA
                          then begin
                             edi := -os;
                             syoKut := 1;  end         //<Liittymäosalle
                          else begin                   Wrb('Jno-BtnClik 1/2');
                           //edi := os;                                                    //WBeep([200,50, 200,500]);
                           //edi := os-tmpJohto.LocationIndex;                             //< edi := os =>...+8.0.0
                             edi := tmpJohto.LocationIndex -edv.YLE.SorceCount.arvoInt +1; //< edi := os =>...+8.0.0
                             syoKut := 2;  end;        //<Norm.johto-osalle                //' //DEVELOPER2 tarkista???
                          editSyoFrm;                  //<Editoi +ottaa valinnat vastaan: käy läpi Johto-osan ao. rivit, Laskentaan alempna. (Komm.+120.6)
                           LaskeeOdFrm.NayLaskeeOdota; //<Hoitaa myös CurTiimalasin +3.0.2
{-6.2.x Siirretty      } //£$£u edvNewFrm.Update;      //<Pakottaa EdvFrm :n valmiiksi ennenMuitaEventejä. +3.0.2, -1412 (oli vielä 1211´ssa).
{ SyottoFrm :iin       }  laskeEdvArvotOk (1);
{ OkBtnClick -eventiin.}  TEdvNewFrm(owner).UpdateValues;
                                                       Wrb('Jno-BtnClik 2/2=ulos.'); //WBeep([200,50, 200,50, 200,500]);
                       end;
      JOHTO_LAST     :begin
                         {syoKut := 3;  editSyoFrm;
                           LaskeeOdFrm.NayLaskeeOdota; //<Hoitaa myös CurTiimalasin +3.0.2
                           edvNewFrm.Update;           //<Pakottaa EdvFrm :n valmiiksi ennenMuitaEventejä. +3.0.2
                          tmpJohto.NjL := edv.NjL;}
                       end;
  end;
  LaskeeOdFrm.Close;         //<Hoitaa myös Cursorin +3.0.2
end;

///////////////////////////////////////////////////////////////////////////////
{ Hiiren liikkeet }
procedure TJohdot.MouseMove(col,row: integer);    //<12.0.0:  Col mukaan jotta PANELIssa move erottuisi.
begin
   //Jrow := row;                                 //< 3.0.0 DEVELOPER1: Jrow -esittely + init.: EdvNew.PAS :ssa.  -130.2e:  Siirretty alas
     if (AvusteMove = TRUE) and NOT NjFrm.Focused
        and NOT DetEvFrm.Showing                  //<DEVELOPER1 +1.1.2, jottei DetEvFrm jäisi alle.. EI WORKI  +3.0.0
        and (EdvNewFrm.ChkBxAv.State IN [cbChecked,cbGrayed])   //< +2.0.5,  cbGrayed +8.0.5
     then begin                        //<BEGIN,DEVELOPER1: Lisätty ActiveTesti+Jrow sijoitus, tarve: ks. Click + DblClick
//KoeW ('Jt           MouseMove(cr):           col:' +Ints(col) +' row:' +Ints(row), 1); //<12.0.0
//message Hint 'Johdot.PAS´ssa COL virittelyä.'
//if isDebuggerPresent  then EdvNewFrm.KuvausEdit.Text := 'c' +Ints(Col) +' r' +Ints(row);  //+130.2e.
        if (col IN [0,1])              //<+12.0.0: RvOtsikkoPanelissa sarakkeet 0 ja 1.      +130.2e: or ...
        then begin avust(row);         //,,+130.2e: Jotta PohjaClick/DblClick ja HeaderClick/HeaderDblClick tunnisaisi rvn 22.
           row := row +200;  end       //           row+200  =Voidaan tunnistaa OTSPANELILLE.
        else if (col<0)  then begin    //<,130.2e:  Ollaan JOHTO-OSAsarakkeissa, ei OtsPaneliGrid´ssä (HeaderGrid).
           if row=22
           then avust(50)              //<141.1: 50 => 22, EI SITTENKÄÄN, MUTTA SyottoAv´ssa mutettava ehdot Rv=22 => Rv=55
           else avust(row);            //<''+130.2e:  uk-rivin(22) avuste nyt uusi(50), omakseen. '=Ohjaa BASE_0_PaaEdv_e22_4¤4 => ASE_0_PaaEdv_e50_uk=NytOK
           row := row +100;            //<''+130.2e:  row+100  = Voidaan tunnistaa JOHTO-OSILLE.
        end;
        Jrow := row;                   //<DEVELOPER1: 130.2e: Jotta PohjaClik ja DblClick antaisi oikean avusteen.
     end;                              //<DEVELOPER1  'Jrow -esittely + init.: EdvNew.PAS :ssa  -3.0.0
end;

///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.HeaderGridMouseMove(Sender: TObject; Shift: TShiftState; X,Y: Integer);      VAR row, col, aX{12.0.0}: integer;  sa :string{+120.5};
   procedure wFileen(si :string);     begin end;{VAR ff :TextFile;  nm :string;      begin//+120.5 Tämä kirjoittaa fileeseen. -120.5m
      nm := '\\Reijo-xp\e\Projektit XE2\NolaKehi\BIN\__WrHeaderPohjaClick.txt';
      AssignFile(ff,nm);
      if FileExists (nm)                                //<Err = File not found - %s ELLEI edRv tai alkutesti
         then Append(ff)
         else Rewrite(ff);
      Writeln(ff,si);
      Flush(ff);
      Close(ff);
   end;//wFileen }
//''''''''''''''''''''''+120.5
                                 //12.0.0: Tultiin DataMouseMove´sta, missä X´ään sijoitettin COL= -1*(LocationIndex+1) jotta 0 ja 1 jäisi
begin                            // HeaderPanel´ille sen COL 0 ja 1). Avusteille yms. JOHTO-OSA(sarake) saadaan COL := ABS(Col)-1.
   aX := x;
   if aX<0  then
      x := 1;
   HeaderGrid.MouseToCell(x,y, col,row);
   if aX<0  then                 //<DataMouseMove´ssa oli COL jo määritetty "juonisti", ks. edellä. Ei muuten väliä COL-
      COL := aX;                 // arvolla kunhan 0 ja 1 tarkoittavat HeaderPanel´in sarakkeita.
 (*if IsDebuggerPresent  then begin                    //<+120.5  120.5i: Frm.Caption => LisaLbl.Caption
      EdvNewFrm.LisaLbl.Caption := 'HeaderGrd Col:' +Ints(Col) + '  Row:' +Ints(Row);
      EdvNewFrm.LisaLbl.Visible := true;
     {EdvNewFrm.JohdotDataPohja.MouseToCell(x,y, col,row);  //<,,Ei onaa.
      sa := 'c' +Ints(col) +' r{' +Ints(row);
      EdvNewFrm.LahdotGrid.MouseToCell(x,y, col,row);
      sa := sa +'  c' +Ints(col) +' r' +Ints(row);
      EdvNewFrm.JohdotDataPohja.Canvas.TextOut(50,300, sa);}
   end;*)                                             {if isDebuggerPresent  then begin EdvNewFrm.LisaLbl.Visible := true;
                                                          EdvNewFrm.LisaLbl.Caption := TControl(Sender).Name +' col:' +Ints(Col) +' rw:' +Ints(Row);  end;}
   MouseMove(col,row + 6);                              //,,+120.5 ,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
   if Shift=[ssShift,ssCtrl]                            //<ssAlt vex, näppärämpi ilman.  HYVÄ:  fileen kun ssSft+ssAlt
      then if (row>=0) and (row<>eRw) and fRePunKehi    //<eRw alkuarvo Create´ssa.
   then begin
    //Windows.Beep(200,500);                            //<Ei worki.
      eRw := row;
      sa := 'EDV_HEADERS=' +EDV_HEADERS;
      {sa := EdvNewFrm.Johdot.HeaderGrid.Cells[1,row];
      EdvNewFrm.KuvausEdit.Text := sa;                  //<On hyvä että myös näkyy jossain, näkee nopeammin kuin filestä.}
      wFileen(sa);
   end;                                                 //<''+120.5'''''''''''''''''''''''''''''''''''''''''''''''''''''}
//KoeEdiInfo ('Jt HeaderGridMouseMove(xy) x:' +Ints(x) +' y:' +Ints(y) +'  col:' +Ints(col) +' row:' +Ints(row), 1);
end;//HeaderGridMouseMove

///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.PohjaClick(Sender: TObject);      VAR w :integer;      begin
    if EdvNewFrm.ChkBxAv.State<>cbUnChecked  then begin //< +2.0.5
       fSyoAktv (0);
       w := Jrow;
       if (w=222) or (w=122)  then w := 50;
       avust (w);                                       //<DEVELOPER1  <'+130.2e:  w=122 ks. MouseMove.
       avuChkSft (10);  end;                            //< +2.0.5 DEVELOPER1
    TEdvNewFrm(owner).PohjaClick(sender);
end;

///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.PohjaDblClick(Sender: TObject);      VAR w :integer;      begin
    syoAvOn := true;                         //< +2.0.5 DEVELOPER1
    avuChkSft (10);                          //< +2.0.5 DEVELOPER1
    w := Jrow;
    if (w=222) or (w=122)  then w := 50;
    avust (w);                               //<DEVELOPER1  ''+130.2e:  w=122 222 ks. MouseMove.
    TEdvNewFrm(owner).PohjaDblClick(sender); //<-"-   Vapauttaa avusteen, koska ei SYOAKTV := TR, vrt ed. POHJACLICK
end;

///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.HeaderClick(Sender: TObject);      VAR w :integer;      begin
   if EdvNewFrm.ChkBxAv.State<>cbUnChecked  then begin //< +2.0.5
      fSyoAktv (0);
      w := Jrow;
      if (w=222) or (w=122)  then w := 50;
      avust (w);                                       //<''+130.2e:  w=122 222 ks. MouseMove.
      avuChkSft (10);  end;                            //<DEVELOPER1
   TEdvNewFrm(owner).HeaderClick(sender);
end;

///////////////////////////////////////////////////////////////////////////////
procedure TJohdot.HeaderDblClick(Sender: TObject);      VAR w :integer;      begin
   syoAvOn := true;                         //< +2.0.5 DEVELOPER1
   avuChkSft (10);                          //< +2.0.5 DEVELOPER1
   w := Jrow;
   if (w=222) or (w=122)  then w := 50;
   avust (w);                               //<DEVELOPER1  <''+130.2e:  w=122 ks. MouseMove.
   TEdvNewFrm(owner).HeaderDblClick(sender);
end;

end.
