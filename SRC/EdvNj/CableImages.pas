{
* Copyright (c) 2020, Reijo Pursiainen, Hannu Pursiainen
* All rights reserved.
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of Reijo Pursiainen, Hannu Pursiainen nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY REIJO PURSIAINEN, HANNU PURSIAINEN AND
* CONTRIBUTORS ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING,
* BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
* A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL REIJO PURSIAINEN,
* HANNU PURSIAINEN AND CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
}

///////////////////////////////////////////////////////////////////////////////
//
// FileName:  CableImages.pas
// Location:  src\components
// Abstract:  Images that are used in the edv cable

// ###############################################################################################################
// ###############################################################################################################
// Glob./Localit muuttujat ja yleiskuvaukset, ks. ..Edv\Johto.PAS                                   10.0.4
// ###############################################################################################################
// ###############################################################################################################
///////////////////////////////////////////////////////////////////////////////
//
// Following fields are automatically generated by the version control system:
//
// $Revision: 1.4 $
//     $Date: 2005/10/09 14:00:45 $
//
///////////////////////////////////////////////////////////////////////////////
//
// Change Log. Old log entries can be removed by deleting them.
// $Log: CableImages.pas,v $
// Revision 1.4  2005/10/09 14:00:45  DEVELOPER2
// Reijolta 26.9.2005
//
// 
// 4     28.02.04 13:05 DEVELOPER2
// Reijolta 28.2.2004
// 
// 3     22.11.03 10:53 DEVELOPER2
// Pystyssä olevat versiot symboleista lisätty
// 
// 2     9.11.03 12:54 DEVELOPER2
// Lisätty sulakkeen läpi menevä viiva.
// 
// 1     1.08.02 17:28 DEVELOPER2

unit CableImages;

interface

uses
  Windows, graphics, extctrls;

type
  // Type definition for a procedure that format edv image
  TEdvStartImageFormatter = procedure(image: TImage; horizontal: boolean);

  // Definition for the image
  TEdvStartImageDef = RECORD
    name: string;              // String that is used for selecting the image
    imageHorizontal: TImage;   // Horizontal version of the image
    imageVertical: TImage;     // VErtical version of the image
    formatFunc: TEdvStartImageFormatter; // Function that creates the image
  end;

  // Initializes edvStartImages array. Has to be called before
  // array is used.
  procedure CreateCableImages;
  procedure DestroyCableImages;

  // Functions that are used for formating images
  function  half (mitta :integer) :integer;
  procedure Sulake (image: TImage; horizontal: boolean);
  procedure Katkaisija (image: TImage; horizontal: boolean);
  procedure SJliit(image: TImage; horizontal: boolean);
  procedure PJliit(image: TImage; horizontal: boolean);
  procedure Gener (image: TImage; horizontal: boolean);
  procedure UPS   (image: TImage; horizontal: boolean);

const
  // Defines which image represents the fuse image
  CABLE_IMAGES_SULAKE = 1;

var
   // Known edv start images. New images can be added to list.
   // 1=Transformer  2=LV-Cable  3=Generator  4=UPS JÄRJESTYS OLTAVA SAMA TAULUKOSSA.!!!!!!!!!!!!!!!
   SorceImages: array [1..4] of TEdvStartImageDef = (
    (name: 'SJ-liitin';    imageHorizontal: NIL; imageVertical: NIL; formatFunc: SJliit),
    (name: 'PJ-liitin';    imageHorizontal: NIL; imageVertical: NIL; formatFunc: PJliit),
    (name: 'Generaattori'; imageHorizontal: NIL; imageVertical: NIL; formatFunc: Gener),
    (name: 'UPS';          imageHorizontal: NIL; imageVertical: NIL; formatFunc: UPS)
   );
   ProtectImages: array [1..2] of TEdvStartImageDef = (
    (name: 'Sulake';       imageHorizontal: NIL; imageVertical: NIL; formatFunc: Sulake),
    (name: 'Katkaisija';   imageHorizontal: NIL; imageVertical: NIL; formatFunc: Katkaisija)
   );

implementation

uses
  defs, classes;

///////////////////////////////////////////////////////////////////////////////
procedure CreateCableImages;
var
  x: integer;
begin
  // Create and format images
  for x := 1 to Length(SorceImages)  do
  begin
    SorceImages[x].imageHorizontal := TImage.Create(nil);
    SorceImages[x].imageVertical := TImage.Create(nil);
    SorceImages[x].formatFunc(SorceImages[x].imageHorizontal, true);
    SorceImages[x].formatFunc(SorceImages[x].imageVertical, false);
  end;
  for x := 1 to Length(ProtectImages)  do
  begin
    ProtectImages[x].imageHorizontal := TImage.Create(nil);
    ProtectImages[x].imageVertical := TImage.Create(nil);
    ProtectImages[x].formatFunc(ProtectImages[x].imageHorizontal, true);
    ProtectImages[x].formatFunc(ProtectImages[x].imageVertical, false);
  end;
end;

///////////////////////////////////////////////////////////////////////////////
procedure DestroyCableImages;
var
  x: integer;
begin
  // Delete images
  for x := 1 to Length(SorceImages)  do
  begin
    SorceImages[x].imageHorizontal.Free;
    SorceImages[x].imageVertical.Free;
  end;
  for x := 1 to Length(ProtectImages)  do
  begin
    ProtectImages[x].imageHorizontal.Free;
    ProtectImages[x].imageVertical.Free;
  end;
end;

///////////////////////////////////////////////////////////////////////////////
function half (mitta :integer) :integer;
begin
  result := trunc (mitta/2 {+0.5});
end;

///////////////////////////////////////////////////////////////////////////////
procedure Sulake (image: TImage; horizontal: boolean);
const
  WIDTH  = 20;
  HEIGTH = 10;
var
  aRect: TRect;
begin
  if horizontal then
  begin
    // Horizontal version
    image.width :=  WIDTH +4;
    image.height := HEIGTH+1;

    // Draw a line through the fuse
    image.canvas.MoveTo(0, image.height div 2);
    image.canvas.LineTo(image.width, image.height div 2);
  end
  else
  begin
    // Vertical version
    image.width :=  HEIGTH+2;
    image.height := WIDTH +2;

    // Draw a line through the fuse
    image.canvas.MoveTo(image.width div 2, 0);
    image.canvas.LineTo(image.width div 2, image.height);
  end;

  with Image.Canvas  do begin
    image.canvas.pen.color := EDV_JOHTO_COLOR;
    image.canvas.pen.width := EDV_JOHTO_WIDTH;
    image.canvas.pen.style := psSolid;
    image.canvas.brush.color := EDV_JOHTO_COLOR;
    image.canvas.Brush.style := bsSolid;

    aRect.Top :=    0;
    aRect.Left :=   1;
    aRect.Bottom := Image.Height;
    aRect.Right :=  Image.Width;
    image.canvas.FrameRect(aRect);
  end;
end;

///////////////////////////////////////////////////////////////////////////////
procedure Katkaisija (image: TImage; horizontal: boolean);
VAR
  aRect: TRect;
begin
  image.width := 15;
  image.height := 15;
  with Image.Canvas  do begin
    image.canvas.pen.color := EDV_JOHTO_COLOR;
    image.canvas.pen.width := EDV_JOHTO_WIDTH;
    image.canvas.pen.style := psSolid;
    image.canvas.brush.color := EDV_JOHTO_COLOR;
    image.canvas.Brush.style := bsSolid;

    arect.top :=    0;
    arect.Left :=   1;
    arect.bottom := image.height;
    arect.right :=  Image.Width;
    image.canvas.FrameRect(aRect);

    MoveTo(1, 0);
    LineTo(image.width, image.height);
    MoveTo(0,           image.height);
    LineTo(image.width, 0);
  end;
end;

///////////////////////////////////////////////////////////////////////////////
procedure SJliit(image: TImage; horizontal: boolean);
const
  WIDTH  = 20;
  HEIGTH = 12;
begin
  with Image.Canvas  do begin
    pen.color := EDV_JOHTO_COLOR;
    pen.width := EDV_JOHTO_WIDTH;
    pen.style := psSolid;
    brush.color := EDV_JOHTO_COLOR;
    Brush.style := bsClear;

    if horizontal then
    begin
      // Horizontal version
      image.width := WIDTH;
      image.height := HEIGTH;

      Ellipse(0,0, image.height, image.height); //<Muuntajan 1.osan VYK,OAK
      Ellipse(image.width - image.height, 0, image.width, image.height); //<Muuntajan 2.osan VYK,OAK
    end
    else
    begin
      // Vertical version
      image.width := HEIGTH;
      image.height := WIDTH;

      Ellipse(0,0, image.width, image.width); //<Muuntajan 1.osan VYK,OAK
      Ellipse(0,   image.height - image.width, image.width, image.height); //<Muuntajan 2.osan VYK,OAK
    end;
  end;
end;

///////////////////////////////////////////////////////////////////////////////
procedure PJliit(image: TImage; horizontal: boolean);
VAR
  X,Y,h,w,w2{½w} :integer;
begin
  image.Width :=  14; //<Oli 15. Parittomalla pixelimäärällä +1 aiheuttaa yhden ohi imagealueen, todettu.
  image.Height := 12;

  with Image.Canvas  do begin
    pen.color := EDV_JOHTO_COLOR;
    pen.width := EDV_JOHTO_WIDTH;
    pen.style := psSolid;
    brush.color := EDV_JOHTO_COLOR;
    image.canvas.Brush.style := bsClear;

    if horizontal then
    begin
       X := 0;        Y := half(Image.Height);
       MoveTo (X,     Y-half(image.Width));    //<VYK
       LineTo (X,     Y+half(image.Width));    //<Alas
       LineTo (X+trunc(0.9*image.Width), Y);   //<Oik. kärkeen
       LineTo (X,     Y-half(image.Width));    //<VYK
       MoveTo (X+trunc(0.9*image.Width), Y);   //<Kaapelipäätteen oikea kärki
       LineTo (Image.Width,Y);  end
    else begin                                 //<,,Vertical DEVELOPER1
       h := image.Height;
       w := image.Height;
       w2 := half (w);
       if w/2>w2  then w2 := w2 +1;  //<Parittomalla pixelimäärällä ei muuten kohdistu oikein. Nyt TURHA, OK.
       X := 1{0};    Y := 0;         //<VYK
       MoveTo (X,    Y);             //<VYK
       LineTo (X+w,  Y);             //<OYK
       LineTo (X+w2, Y+h);           //<Keskelle alas
       LineTo (X,    Y);             //<VYK
    end;
  end;
end;

///////////////////////////////////////////////////////////////////////////////
procedure Gener(image: TImage; horizontal: boolean);
begin
  image.width := 20;
  image.height := 20;
  with Image.Canvas  do begin
    image.canvas.pen.color := EDV_JOHTO_COLOR;
    image.canvas.pen.width := EDV_JOHTO_WIDTH;
    image.canvas.pen.style := psSolid;
    image.canvas.brush.color := EDV_JOHTO_COLOR;
    image.canvas.Brush.style := bsClear;
    Brush.Color := clWhite;
    Ellipse(0,0, image.Width, image.Height); //<Generaattoriympyrä VYK,OAK
    Font.Size := 8;
    Pen.Width := 1;
    TextOut(half(image.width - TextWidth('G')),           // G-keskelle ympyrää
            half(image.height - TextHeight('G')), 'G');
  end;
end;

///////////////////////////////////////////////////////////////////////////////
procedure UPS (image: TImage; horizontal: boolean);
const
  WIDTH  = 20; //<Image sallii vain max.leveyden 20 - viivaleveys molemmista
  HEIGTH = 16; // reunoista, koklattu. WIDTH 21 ei enää onaa.
VAR X,Y, h{,h2½h},w{,w2½w} :integer;
begin
  image.width :=  WIDTH;
  image.height := HEIGTH;

  with Image.Canvas  do begin
    pen.color := EDV_JOHTO_COLOR;
    pen.width := EDV_JOHTO_WIDTH;
    pen.style := psSolid;
    brush.color := EDV_JOHTO_COLOR;
    image.canvas.Brush.style := bsClear;

    h := HEIGTH;   //h2 := half (h);
    w := WIDTH;    //w2 := half (w);
    X := 0;        Y := 0;
    MoveTo (X,     Y);      //<VYK
    LineTo (X+w-1, Y);      //<OYK  Image sallii vain max.leveyden 20 - viivaleveys molemmista
    LineTo (X+w-1, Y+h-1);  //<OAK  reunoista, koklattu. WIDTH 21 ei enää onaa.
    LineTo (X,     Y+h-1);  //<VAK
    LineTo (X,     Y);      //<VYK}
   {X := 0;      Y := 0;
    MoveTo (X,   Y);    //<VYK
    LineTo (X+w, Y);    //<OYK
    LineTo (X+w, Y+h);  //<OAK
    LineTo (X,   Y+h);  //<VAK
    LineTo (X,   Y);    //<VYK}
    Font.Size := 8;
    Pen.Width := 1;
    TextOut (half(w - TextWidth('ups')+2),          // ups -teksti keskelle suorakaidetta,  141.1 +2
             half(h - TextHeight('ups')-3), 'ups'); //< -3 korkeusaseman korjaus.
  end;
end;

end.
